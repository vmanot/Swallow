{"metadata":{"title":"Equatable","externalID":"s:SQ","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"Equatable","kind":"identifier"}],"role":"symbol","roleHeading":"Protocol","symbolKind":"protocol","modules":[{"name":"Compute"}],"navigatorTitle":[{"kind":"identifier","text":"Equatable"}]},"kind":"symbol","sections":[],"topicSections":[{"title":"Operators","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable\/!=(_:_:)","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable\/==(_:_:)-3axv1"],"anchor":"Operators","generated":true}],"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"paths":["\/documentation\/compute\/equatable"],"traits":[{"interfaceLanguage":"swift"}]}],"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["macOS"],"languages":["swift"],"tokens":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Equatable","kind":"identifier"}]}]},{"kind":"content","content":[{"level":2,"anchor":"overview","text":"Overview","type":"heading"},{"inlineContent":[{"text":"Types that conform to the ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" protocol can be compared for equality","type":"text"},{"type":"text","text":" "},{"type":"text","text":"using the equal-to operator ("},{"type":"codeVoice","code":"=="},{"text":") or inequality using the not-equal-to","type":"text"},{"text":" ","type":"text"},{"text":"operator (","type":"text"},{"code":"!=","type":"codeVoice"},{"type":"text","text":"). Most basic types in the Swift standard library conform to"},{"text":" ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Some sequence and collection operations can be used more simply when the","type":"text"},{"text":" ","type":"text"},{"text":"elements conform to ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":". For example, to check whether an array"},{"type":"text","text":" "},{"type":"text","text":"contains a particular value, you can pass the value itself to the"},{"text":" ","type":"text"},{"type":"codeVoice","code":"contains(_:)"},{"type":"text","text":" method when the array’s element conforms to "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"instead of providing a closure that determines equivalence. The following"},{"text":" ","type":"text"},{"text":"example shows how the ","type":"text"},{"code":"contains(_:)","type":"codeVoice"},{"type":"text","text":" method can be used with an array of"},{"text":" ","type":"text"},{"text":"strings.","type":"text"}]},{"type":"codeListing","syntax":null,"code":["let students = [\"Kofi\", \"Abena\", \"Efua\", \"Kweku\", \"Akosua\"]","","let nameToCheck = \"Kofi\"","if students.contains(nameToCheck) {","    print(\"\\(nameToCheck) is signed up!\")","} else {","    print(\"No record of \\(nameToCheck).\")","}","\/\/ Prints \"Kofi is signed up!\""]},{"type":"heading","level":1,"anchor":"Conforming-to-the-Equatable-Protocol","text":"Conforming to the Equatable Protocol"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Adding "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" conformance to your custom types means that you can use"},{"type":"text","text":" "},{"type":"text","text":"more convenient APIs when searching for particular instances in a"},{"text":" ","type":"text"},{"type":"text","text":"collection. "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" is also the base protocol for the "},{"type":"codeVoice","code":"Hashable"},{"text":" and","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" protocols, which allow more uses of your custom type, such as"},{"type":"text","text":" "},{"type":"text","text":"constructing sets or sorting the elements of a collection."}]},{"inlineContent":[{"type":"text","text":"You can rely on automatic synthesis of the "},{"code":"Equatable","type":"codeVoice"},{"text":" protocol’s","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"requirements for a custom type when you declare "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" conformance in"},{"type":"text","text":" "},{"type":"text","text":"the type’s original declaration and your type meets these criteria:"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"For a ","type":"text"},{"type":"codeVoice","code":"struct"},{"type":"text","text":", all its stored properties must conform to "},{"type":"codeVoice","code":"Equatable"},{"text":".","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"For an "},{"type":"codeVoice","code":"enum"},{"text":", all its associated values must conform to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":". (An","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"enum"},{"type":"text","text":" without associated values has "},{"code":"Equatable","type":"codeVoice"},{"text":" conformance even","type":"text"},{"type":"text","text":" "},{"text":"without the declaration.)","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To customize your type’s "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" conformance, to adopt "},{"type":"codeVoice","code":"Equatable"},{"text":" in a","type":"text"},{"type":"text","text":" "},{"text":"type that doesn’t meet the criteria listed above, or to extend an existing","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"type to conform to "},{"code":"Equatable","type":"codeVoice"},{"text":", implement the equal-to operator (","type":"text"},{"code":"==","type":"codeVoice"},{"text":") as","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a static method of your type. The standard library provides an"},{"text":" ","type":"text"},{"text":"implementation for the not-equal-to operator (","type":"text"},{"type":"codeVoice","code":"!="},{"text":") for any ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":" ","type":"text"},{"type":"text","text":"type, which calls the custom "},{"code":"==","type":"codeVoice"},{"text":" function and negates its result.","type":"text"}]},{"inlineContent":[{"text":"As an example, consider a ","type":"text"},{"type":"codeVoice","code":"StreetAddress"},{"text":" class that holds the parts of a","type":"text"},{"text":" ","type":"text"},{"text":"street address: a house or building number, the street name, and an","type":"text"},{"type":"text","text":" "},{"text":"optional unit number. Here’s the initial declaration of the","type":"text"},{"type":"text","text":" "},{"code":"StreetAddress","type":"codeVoice"},{"type":"text","text":" type:"}],"type":"paragraph"},{"code":["class StreetAddress {","    let number: String","    let street: String","    let unit: String?","","    init(_ number: String, _ street: String, unit: String? = nil) {","        self.number = number","        self.street = street","        self.unit = unit","    }","}"],"syntax":null,"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now suppose you have an array of addresses that you need to check for a"},{"text":" ","type":"text"},{"text":"particular address. To use the ","type":"text"},{"type":"codeVoice","code":"contains(_:)"},{"text":" method without including a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"closure in each call, extend the "},{"code":"StreetAddress","type":"codeVoice"},{"type":"text","text":" type to conform to"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":".","type":"text"}]},{"code":["extension StreetAddress: Equatable {","    static func == (lhs: StreetAddress, rhs: StreetAddress) -> Bool {","        return","            lhs.number == rhs.number &&","            lhs.street == rhs.street &&","            lhs.unit == rhs.unit","    }","}"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"StreetAddress"},{"text":" type now conforms to ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":". You can use "},{"type":"codeVoice","code":"=="},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"text","text":"check for equality between any two instances or call the"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":"-constrained ","type":"text"},{"code":"contains(_:)","type":"codeVoice"},{"text":" method.","type":"text"}]},{"code":["let addresses = [StreetAddress(\"1490\", \"Grove Street\"),","                 StreetAddress(\"2119\", \"Maple Avenue\"),","                 StreetAddress(\"1400\", \"16th Street\")]","let home = StreetAddress(\"1400\", \"16th Street\")","","print(addresses[0] == home)","\/\/ Prints \"false\"","print(addresses.contains(home))","\/\/ Prints \"true\""],"syntax":null,"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Equality implies substitutability—any two instances that compare equally"},{"type":"text","text":" "},{"type":"text","text":"can be used interchangeably in any code that depends on their values. To"},{"type":"text","text":" "},{"type":"text","text":"maintain substitutability, the "},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator should take into account all"},{"text":" ","type":"text"},{"text":"visible aspects of an ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"text":" type. Exposing nonvalue aspects of","type":"text"},{"text":" ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" types other than class identity is discouraged, and any that","type":"text"},{"type":"text","text":" "},{"inlineContent":[{"text":"are","type":"text"}],"type":"emphasis"},{"text":" exposed should be explicitly pointed out in documentation.","type":"text"}]},{"inlineContent":[{"text":"Since equality between instances of ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" types is an equivalence"},{"type":"text","text":" "},{"type":"text","text":"relation, any of your custom types that conform to "},{"type":"codeVoice","code":"Equatable"},{"text":" must","type":"text"},{"type":"text","text":" "},{"text":"satisfy three conditions, for any values ","type":"text"},{"type":"codeVoice","code":"a"},{"text":", ","type":"text"},{"code":"b","type":"codeVoice"},{"type":"text","text":", and "},{"code":"c","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"codeVoice","code":"a == a"},{"text":" is always ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":" (Reflexivity)"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"a == b","type":"codeVoice"},{"type":"text","text":" implies "},{"code":"b == a","type":"codeVoice"},{"text":" (Symmetry)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"a == b"},{"type":"text","text":" and "},{"type":"codeVoice","code":"b == c"},{"type":"text","text":" implies "},{"type":"codeVoice","code":"a == c"},{"type":"text","text":" (Transitivity)"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Moreover, inequality is the inverse of equality, so any custom","type":"text"},{"text":" ","type":"text"},{"text":"implementation of the ","type":"text"},{"code":"!=","type":"codeVoice"},{"type":"text","text":" operator must guarantee that "},{"type":"codeVoice","code":"a != b"},{"type":"text","text":" implies"},{"type":"text","text":" "},{"code":"!(a == b)","type":"codeVoice"},{"type":"text","text":". The default implementation of the "},{"type":"codeVoice","code":"!="},{"text":" operator function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"satisfies this requirement."}]},{"type":"heading","anchor":"Equality-is-Separate-From-Identity","level":2,"text":"Equality is Separate From Identity"},{"type":"paragraph","inlineContent":[{"text":"The identity of a class instance is not part of an instance’s value.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Consider a class called "},{"type":"codeVoice","code":"IntegerRef"},{"text":" that wraps an integer value. Here’s","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the definition for "},{"type":"codeVoice","code":"IntegerRef"},{"type":"text","text":" and the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" function that makes it"},{"type":"text","text":" "},{"type":"text","text":"conform to "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":":"}]},{"type":"codeListing","code":["class IntegerRef: Equatable {","    let value: Int","    init(_ value: Int) {","        self.value = value","    }","","    static func == (lhs: IntegerRef, rhs: IntegerRef) -> Bool {","        return lhs.value == rhs.value","    }","}"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"The implementation of the "},{"type":"codeVoice","code":"=="},{"text":" function returns the same value whether its","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"two arguments are the same instance or are two different instances with"},{"type":"text","text":" "},{"type":"text","text":"the same integer stored in their "},{"type":"codeVoice","code":"value"},{"text":" properties. For example:","type":"text"}]},{"code":["let a = IntegerRef(100)","let b = IntegerRef(100)","","print(a == a, a == b, separator: \", \")","\/\/ Prints \"true, true\""],"type":"codeListing","syntax":null},{"inlineContent":[{"type":"text","text":"Class instance identity, on the other hand, is compared using the"},{"type":"text","text":" "},{"type":"text","text":"triple-equals identical-to operator ("},{"type":"codeVoice","code":"==="},{"type":"text","text":"). For example:"}],"type":"paragraph"},{"syntax":null,"code":["let c = a","print(c === a, c === b, separator: \", \")","\/\/ Prints \"true, false\""],"type":"codeListing"}]}],"abstract":[{"text":"A type that can be compared for value equality.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute"]]},"relationshipsSections":[{"title":"Inherited By","type":"inheritedBy","kind":"relationships","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AdditiveArithmetic","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryFloatingPoint","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryInteger","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ComplexNumeric","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DurationProtocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FixedWidthInteger","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPoint","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Hashable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/InstantProtocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Numeric","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/OptionSet","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Quaternion","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD-swift.protocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SetAlgebra","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SignedInteger","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SignedNumeric","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Strideable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/StringProtocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsignedInteger"]},{"identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyHashable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyIndex","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyKeyPath","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Array","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ArraySlice","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ArrayTree","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ArrayTreeChildren","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AutoreleasingUnsafeMutablePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Bag\/Key","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BidirectionalMap","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Bool","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/CommitID","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/Difference","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/Difference\/Deletion","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/Difference\/Insertion","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/CommitID","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/Difference","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/Difference\/Deletion","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/Difference\/Insertion","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Character","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ClosedRange","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ClosedRange\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CodingUserInfoKey","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference\/Change","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ContiguousArray","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary\/Keys-swift.struct","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DiscontiguousSlice","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DiscontiguousSlice\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Double","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Duration","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/EmptyCollection","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FlattenSequence\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float16","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPointClassification","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPointRoundingRule","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPointSign","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int128","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int16","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int32","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int64","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int8","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/KeyPath","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/LazyPrefixWhileSequence\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/LinkedList","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ManagedBufferPointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Matrix","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/MergeSplitSequence","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Mirror\/DisplayStyle-swift.enum","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Never","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ObjectIdentifier","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/OpaquePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Optional","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/PartialKeyPath","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Range","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/RangeSet","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/RangeSet\/Ranges-swift.struct","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReferenceTree","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReferenceWritableKeyPath","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Result","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReversedCollection\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD16","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD2","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD3","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD32","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD4","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD64","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD8","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMDMask","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Set","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Set\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Substring","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/TreeIndexPath","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/TreeTraversalAlgorithmType","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt128","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt16","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt32","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt64","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt8","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/CanonicalCombiningClass","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/GeneralCategory","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/NumericType","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/Scalar","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/UTF32","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnicodeDecodingResult","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutablePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutableRawPointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeRawPointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/WritableKeyPath","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/simd-swift.module.extension\/simd_quatd","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/simd-swift.module.extension\/simd_quatf"],"type":"conformingTypes","title":"Conforming Types","kind":"relationships"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable"},"references":{"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer":{"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer","title":"UnsafePointer","url":"\/documentation\/compute\/unsafepointer","kind":"symbol","abstract":[{"type":"text","text":"A pointer for accessing data of a specific type."}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"UnsafePointer","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"UnsafePointer"}],"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Pointee"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/Character":{"title":"Character","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Character","abstract":[{"type":"text","text":"A single extended grapheme cluster that approximates a user-perceived"},{"type":"text","text":" "},{"text":"character.","type":"text"}],"type":"topic","role":"symbol","url":"\/documentation\/compute\/character","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Character"}],"navigatorTitle":[{"kind":"identifier","text":"Character"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Equatable/!=(_:_:)":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable\/!=(_:_:)","role":"symbol","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"!="},{"kind":"text","text":" "},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"}],"kind":"symbol","type":"topic","title":"!=(_:_:)","url":"\/documentation\/compute\/equatable\/!=(_:_:)","abstract":[{"text":"Returns a Boolean value indicating whether two values are not equal.","type":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafeMutableRawPointer":{"kind":"symbol","type":"topic","abstract":[{"text":"A raw pointer for accessing and manipulating untyped data.","type":"text"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutableRawPointer","url":"\/documentation\/compute\/unsafemutablerawpointer","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"UnsafeMutableRawPointer"}],"title":"UnsafeMutableRawPointer","navigatorTitle":[{"kind":"identifier","text":"UnsafeMutableRawPointer"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable":{"url":"\/documentation\/compute\/comparable","type":"topic","kind":"symbol","role":"symbol","abstract":[{"text":"A type that can be compared using the relational operators ","type":"text"},{"code":"<","type":"codeVoice"},{"text":", ","type":"text"},{"code":"<=","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":">="},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":">"},{"text":".","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Comparable"}],"title":"Comparable","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"Comparable","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD4":{"role":"symbol","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"SIMD4","kind":"identifier"}],"navigatorTitle":[{"text":"SIMD4","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD4","abstract":[{"type":"text","text":"A vector of four scalar values."}],"title":"SIMD4","url":"\/documentation\/compute\/simd4"},"doc://com.swallow.documentation.Compute/documentation/Compute/AnyIndex":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"AnyIndex","kind":"identifier"}],"url":"\/documentation\/compute\/anyindex","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyIndex","role":"symbol","abstract":[{"text":"A wrapper over an underlying index that hides the specific underlying type.","type":"text"}],"navigatorTitle":[{"text":"AnyIndex","kind":"identifier"}],"type":"topic","title":"AnyIndex"},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingArray/Difference/Deletion":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Deletion"}],"title":"BranchingArray.Difference.Deletion","abstract":[],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/Difference\/Deletion","url":"\/documentation\/compute\/branchingarray\/difference\/deletion","kind":"symbol","role":"symbol","type":"topic","navigatorTitle":[{"text":"Deletion","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/LazyPrefixWhileSequence/Index":{"type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Index"}],"kind":"symbol","title":"LazyPrefixWhileSequence.Index","abstract":[{"type":"text","text":"A position in a "},{"code":"LazyPrefixWhileCollection","type":"codeVoice"},{"type":"text","text":" or"},{"type":"text","text":" "},{"code":"LazyPrefixWhileBidirectionalCollection","type":"codeVoice"},{"type":"text","text":" instance."}],"url":"\/documentation\/compute\/lazyprefixwhilesequence\/index","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Index","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"Base","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Collection","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Base.Index"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":".","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/LazyPrefixWhileSequence\/Index"},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingArray/CommitID":{"title":"BranchingArray.CommitID","url":"\/documentation\/compute\/branchingarray\/commitid","role":"symbol","type":"topic","abstract":[],"conformance":{"constraints":[{"type":"codeVoice","code":"Branch"},{"type":"text","text":" conforms to "},{"code":"Hashable","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Element"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/CommitID","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"CommitID","kind":"identifier"}],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"CommitID"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/SetAlgebra":{"role":"symbol","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SetAlgebra","kind":"identifier"}],"title":"SetAlgebra","url":"\/documentation\/compute\/setalgebra","abstract":[{"text":"A type that provides mathematical set operations.","type":"text"}],"type":"topic","navigatorTitle":[{"text":"SetAlgebra","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SetAlgebra"},"doc://com.swallow.documentation.Compute/documentation/Compute/Quaternion":{"url":"\/documentation\/compute\/quaternion","navigatorTitle":[{"kind":"identifier","text":"Quaternion"}],"role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"Quaternion","kind":"identifier"}],"abstract":[],"type":"topic","title":"Quaternion","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Quaternion"},"doc://com.swallow.documentation.Compute/documentation/Compute/TreeIndexPath":{"type":"topic","navigatorTitle":[{"text":"TreeIndexPath","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Tree"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"TreeProtocol"},{"type":"text","text":", "},{"type":"codeVoice","code":"Tree.Children"},{"text":" conforms to ","type":"text"},{"code":"Collection","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Tree.Children.Index","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":".","type":"text"}]},"abstract":[],"title":"TreeIndexPath","url":"\/documentation\/compute\/treeindexpath","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/TreeIndexPath","role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"TreeIndexPath","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ContiguousArray":{"url":"\/documentation\/compute\/contiguousarray","role":"symbol","navigatorTitle":[{"text":"ContiguousArray","kind":"identifier"}],"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Element"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"title":"ContiguousArray","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ContiguousArray","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ContiguousArray"}],"type":"topic","abstract":[{"type":"text","text":"A contiguously stored array."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Float16":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float16","navigatorTitle":[{"kind":"identifier","text":"Float16"}],"role":"symbol","title":"Float16","url":"\/documentation\/compute\/float16","type":"topic","abstract":[{"type":"text","text":"A half-precision (16b), floating-point value type."}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Float16"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Set/Index":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Set\/Index","title":"Set.Index","abstract":[{"type":"text","text":"The position of an element in a set."}],"url":"\/documentation\/compute\/set\/index","navigatorTitle":[{"kind":"identifier","text":"Index"}],"type":"topic","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Element","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":".","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Index","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/CodingUserInfoKey":{"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CodingUserInfoKey","navigatorTitle":[{"kind":"identifier","text":"CodingUserInfoKey"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"CodingUserInfoKey","kind":"identifier"}],"role":"symbol","type":"topic","abstract":[{"type":"text","text":"A user-defined key for providing context during encoding and decoding."}],"title":"CodingUserInfoKey","url":"\/documentation\/compute\/codinguserinfokey"},"doc://com.swallow.documentation.Compute/documentation/Compute/DiscontiguousSlice/Index":{"title":"DiscontiguousSlice.Index","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Index"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DiscontiguousSlice\/Index","navigatorTitle":[{"text":"Index","kind":"identifier"}],"url":"\/documentation\/compute\/discontiguousslice\/index","abstract":[{"type":"text","text":"A position in a "},{"type":"codeVoice","code":"DiscontiguousSlice"},{"type":"text","text":"."}],"type":"topic","kind":"symbol","role":"symbol","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Base","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Collection"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/FlattenSequence/Index":{"url":"\/documentation\/compute\/flattensequence\/index","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"Index"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Base"},{"type":"text","text":" conforms to "},{"code":"Collection","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Base.Element","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Collection"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"type":"topic","title":"FlattenSequence.Index","kind":"symbol","abstract":[{"type":"text","text":"A position in a FlattenCollection"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FlattenSequence\/Index"},"doc://com.swallow.documentation.Compute/documentation/Compute/Unicode/CanonicalCombiningClass":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/CanonicalCombiningClass","type":"topic","title":"Unicode.CanonicalCombiningClass","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"CanonicalCombiningClass","kind":"identifier"}],"navigatorTitle":[{"text":"CanonicalCombiningClass","kind":"identifier"}],"url":"\/documentation\/compute\/unicode\/canonicalcombiningclass","role":"symbol","kind":"symbol","abstract":[{"text":"The classification of a scalar used in the Canonical Ordering Algorithm","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"defined by the Unicode Standard."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ObjectIdentifier":{"title":"ObjectIdentifier","navigatorTitle":[{"text":"ObjectIdentifier","kind":"identifier"}],"type":"topic","url":"\/documentation\/compute\/objectidentifier","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ObjectIdentifier","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ObjectIdentifier","abstract":[{"type":"text","text":"A unique identifier for a class instance or metatype."}],"role":"symbol","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt64":{"navigatorTitle":[{"text":"UInt64","kind":"identifier"}],"kind":"symbol","role":"symbol","type":"topic","title":"UInt64","abstract":[{"text":"A 64-bit unsigned integer value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"type."}],"url":"\/documentation\/compute\/uint64","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"UInt64","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt64"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int","abstract":[{"type":"text","text":"A signed integer value type."}],"type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Int","kind":"identifier"}],"navigatorTitle":[{"text":"Int","kind":"identifier"}],"title":"Int","url":"\/documentation\/compute\/int","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD64":{"type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"SIMD64"}],"abstract":[{"type":"text","text":"A vector of 64 scalar values."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD64","navigatorTitle":[{"text":"SIMD64","kind":"identifier"}],"role":"symbol","kind":"symbol","url":"\/documentation\/compute\/simd64","title":"SIMD64"},"doc://com.swallow.documentation.Compute/documentation/Compute/KeyPath":{"type":"topic","role":"symbol","url":"\/documentation\/compute\/keypath","title":"KeyPath","kind":"symbol","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"KeyPath"}],"abstract":[{"type":"text","text":"A key path from a specific root type to a specific resulting value type."}],"navigatorTitle":[{"text":"KeyPath","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/KeyPath"},"doc://com.swallow.documentation.Compute/documentation/Compute/ComplexNumeric":{"role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ComplexNumeric","type":"topic","url":"\/documentation\/compute\/complexnumeric","title":"ComplexNumeric","navigatorTitle":[{"text":"ComplexNumeric","kind":"identifier"}],"abstract":[],"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"ComplexNumeric","kind":"identifier"}],"kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/ClosedRange/Index":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ClosedRange\/Index","type":"topic","abstract":[{"type":"text","text":"A type that represents a position in the collection."}],"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Index"}],"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Bound","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Strideable","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Bound.Stride","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"SignedInteger","type":"codeVoice"},{"text":".","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"kind":"symbol","title":"ClosedRange.Index","navigatorTitle":[{"kind":"identifier","text":"Index"}],"url":"\/documentation\/compute\/closedrange\/index","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/simd-swift.module.extension/simd_quatf":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/simd-swift.module.extension\/simd_quatf","abstract":[],"fragments":[{"kind":"keyword","text":"extension"},{"text":" ","kind":"text"},{"kind":"identifier","text":"simd"},{"text":".","kind":"text"},{"text":"simd_quatf","kind":"identifier","preciseIdentifier":"c:@SA@simd_quatf"}],"title":"simd_quatf","type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"simd_quatf"}],"url":"\/documentation\/compute\/simd-swift.module.extension\/simd_quatf","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingDictionary/Difference/Deletion":{"role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Deletion"}],"title":"BranchingDictionary.Difference.Deletion","url":"\/documentation\/compute\/branchingdictionary\/difference\/deletion","abstract":[],"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Deletion"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/Difference\/Deletion"},"doc://com.swallow.documentation.Compute/documentation/Compute/Unicode/GeneralCategory":{"url":"\/documentation\/compute\/unicode\/generalcategory","navigatorTitle":[{"kind":"identifier","text":"GeneralCategory"}],"role":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"text":" ","kind":"text"},{"text":"GeneralCategory","kind":"identifier"}],"abstract":[{"type":"text","text":"The most general classification of a Unicode scalar."}],"type":"topic","title":"Unicode.GeneralCategory","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/GeneralCategory"},"doc://com.swallow.documentation.Compute/documentation/Compute/FloatingPointRoundingRule":{"kind":"symbol","navigatorTitle":[{"text":"FloatingPointRoundingRule","kind":"identifier"}],"type":"topic","title":"FloatingPointRoundingRule","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPointRoundingRule","abstract":[{"type":"text","text":"A rule for rounding a floating-point number."}],"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FloatingPointRoundingRule","kind":"identifier"}],"url":"\/documentation\/compute\/floatingpointroundingrule"},"doc://com.swallow.documentation.Compute/documentation/Compute/CollectionDifference":{"url":"\/documentation\/compute\/collectiondifference","title":"CollectionDifference","navigatorTitle":[{"text":"CollectionDifference","kind":"identifier"}],"type":"topic","kind":"symbol","conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"ChangeElement"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference","abstract":[{"type":"text","text":"A collection of insertions and removals that describe the difference"},{"type":"text","text":" "},{"type":"text","text":"between two ordered collection states."}],"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CollectionDifference"}],"role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Bag/Key":{"url":"\/documentation\/compute\/bag\/key","role":"symbol","title":"Bag.Key","type":"topic","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Key"}],"navigatorTitle":[{"kind":"identifier","text":"Key"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Bag\/Key","abstract":[]},"doc://com.swallow.documentation.Compute/documentation/Compute/Int8":{"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Int8"}],"url":"\/documentation\/compute\/int8","title":"Int8","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Int8"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int8","abstract":[{"text":"An 8-bit signed integer value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"type."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Range":{"navigatorTitle":[{"kind":"identifier","text":"Range"}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Range","url":"\/documentation\/compute\/range","title":"Range","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Range","kind":"identifier"}],"abstract":[{"type":"text","text":"A half-open interval from a lower bound up to, but not including, an upper"},{"text":" ","type":"text"},{"text":"bound.","type":"text"}],"type":"topic","role":"symbol","conformance":{"constraints":[{"code":"Bound","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Comparable"},{"text":".","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/FixedWidthInteger":{"title":"FixedWidthInteger","kind":"symbol","navigatorTitle":[{"text":"FixedWidthInteger","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FixedWidthInteger","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"FixedWidthInteger","kind":"identifier"}],"abstract":[{"text":"An integer type that uses a fixed size for every instance.","type":"text"}],"type":"topic","url":"\/documentation\/compute\/fixedwidthinteger"},"doc://com.swallow.documentation.Compute/documentation/Compute/FloatingPoint":{"url":"\/documentation\/compute\/floatingpoint","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPoint","title":"FloatingPoint","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FloatingPoint","kind":"identifier"}],"navigatorTitle":[{"text":"FloatingPoint","kind":"identifier"}],"abstract":[{"text":"A floating-point numeric type.","type":"text"}],"kind":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/SignedInteger":{"abstract":[{"type":"text","text":"An integer type that can represent both positive and negative values."}],"kind":"symbol","url":"\/documentation\/compute\/signedinteger","navigatorTitle":[{"kind":"identifier","text":"SignedInteger"}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SignedInteger","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"SignedInteger","kind":"identifier"}],"title":"SignedInteger"},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD3":{"role":"symbol","navigatorTitle":[{"text":"SIMD3","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD3","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"SIMD3","kind":"identifier"}],"abstract":[{"text":"A vector of three scalar values.","type":"text"}],"title":"SIMD3","url":"\/documentation\/compute\/simd3","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Equatable":{"abstract":[{"text":"A type that can be compared for value equality.","type":"text"}],"type":"topic","title":"Equatable","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Equatable"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable","role":"symbol","url":"\/documentation\/compute\/equatable","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Equatable","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Dictionary/Keys-swift.struct":{"fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Keys","kind":"identifier"}],"type":"topic","title":"Dictionary.Keys","url":"\/documentation\/compute\/dictionary\/keys-swift.struct","navigatorTitle":[{"kind":"identifier","text":"Keys"}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary\/Keys-swift.struct","role":"symbol","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Key"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":"."}]},"abstract":[{"text":"A view of a dictionary’s keys.","type":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD-swift.protocol":{"role":"symbol","type":"topic","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"SIMD"}],"navigatorTitle":[{"kind":"identifier","text":"SIMD"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD-swift.protocol","abstract":[{"text":"A SIMD vector of a fixed number of elements.","type":"text"}],"title":"SIMD","url":"\/documentation\/compute\/simd-swift.protocol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Strideable":{"type":"topic","kind":"symbol","role":"symbol","url":"\/documentation\/compute\/strideable","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Strideable","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Strideable"}],"navigatorTitle":[{"text":"Strideable","kind":"identifier"}],"abstract":[{"type":"text","text":"A type representing continuous, one-dimensional values that can be offset"},{"type":"text","text":" "},{"type":"text","text":"and measured."}],"title":"Strideable"},"doc://com.swallow.documentation.Compute/documentation/Compute/TreeTraversalAlgorithmType":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/TreeTraversalAlgorithmType","title":"TreeTraversalAlgorithmType","abstract":[],"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"TreeTraversalAlgorithmType"}],"url":"\/documentation\/compute\/treetraversalalgorithmtype","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"text":"TreeTraversalAlgorithmType","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt128":{"url":"\/documentation\/compute\/uint128","type":"topic","kind":"symbol","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt128","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"UInt128"}],"title":"UInt128","abstract":[{"text":"A 128-bit unsigned integer type.","type":"text"}],"navigatorTitle":[{"text":"UInt128","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ArraySlice":{"navigatorTitle":[{"text":"ArraySlice","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ArraySlice","abstract":[{"text":"A slice of an ","type":"text"},{"type":"codeVoice","code":"Array"},{"type":"text","text":", "},{"code":"ContiguousArray","type":"codeVoice"},{"type":"text","text":", or "},{"type":"codeVoice","code":"ArraySlice"},{"text":" instance.","type":"text"}],"role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ArraySlice"}],"type":"topic","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Element"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"title":"ArraySlice","kind":"symbol","url":"\/documentation\/compute\/arrayslice"},"doc://com.swallow.documentation.Compute/documentation/Compute/MergeSplitSequence":{"type":"topic","navigatorTitle":[{"text":"MergeSplitSequence","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Element"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":"."}]},"abstract":[],"title":"MergeSplitSequence","url":"\/documentation\/compute\/mergesplitsequence","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/MergeSplitSequence","role":"symbol","kind":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"text":" ","kind":"text"},{"text":"MergeSplitSequence","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/BinaryFloatingPoint":{"navigatorTitle":[{"text":"BinaryFloatingPoint","kind":"identifier"}],"type":"topic","title":"BinaryFloatingPoint","abstract":[{"text":"A radix-2 (binary) floating-point type.","type":"text"}],"url":"\/documentation\/compute\/binaryfloatingpoint","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BinaryFloatingPoint","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryFloatingPoint","kind":"symbol","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Result":{"url":"\/documentation\/compute\/result","title":"Result","navigatorTitle":[{"kind":"identifier","text":"Result"}],"type":"topic","kind":"symbol","conformance":{"constraints":[{"code":"Success","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"Failure"},{"type":"text","text":" conforms to "},{"code":"Equatable","type":"codeVoice"},{"text":", and ","type":"text"},{"code":"Failure","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Error"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Result","abstract":[{"text":"A value that represents either a success or a failure, including an","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"associated value in each case."}],"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Result","kind":"identifier"}],"role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/String/Index":{"abstract":[{"type":"text","text":"A position of a character or code unit in a string."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}],"url":"\/documentation\/compute\/string\/index","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String\/Index","kind":"symbol","title":"String.Index","role":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Index"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt8":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"UInt8","kind":"identifier"}],"navigatorTitle":[{"text":"UInt8","kind":"identifier"}],"title":"UInt8","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt8","url":"\/documentation\/compute\/uint8","kind":"symbol","role":"symbol","type":"topic","abstract":[{"type":"text","text":"An 8-bit unsigned integer value"},{"text":" ","type":"text"},{"text":"type.","type":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Substring":{"navigatorTitle":[{"kind":"identifier","text":"Substring"}],"url":"\/documentation\/compute\/substring","title":"Substring","abstract":[{"text":"A slice of a string.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Substring","kind":"identifier"}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Substring","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/AutoreleasingUnsafeMutablePointer":{"type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"AutoreleasingUnsafeMutablePointer"}],"url":"\/documentation\/compute\/autoreleasingunsafemutablepointer","kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"A mutable pointer addressing an Objective-C reference that doesn’t own its"},{"text":" ","type":"text"},{"type":"text","text":"target."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AutoreleasingUnsafeMutablePointer","navigatorTitle":[{"text":"AutoreleasingUnsafeMutablePointer","kind":"identifier"}],"title":"AutoreleasingUnsafeMutablePointer"},"doc://com.swallow.documentation.Compute/documentation/Compute/EmptyCollection":{"url":"\/documentation\/compute\/emptycollection","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"EmptyCollection"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Element"},{"type":"text","text":" conforms to "},{"code":"Copyable","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Escapable","type":"codeVoice"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"abstract":[{"type":"text","text":"A collection whose element type is "},{"code":"Element","type":"codeVoice"},{"text":" but that is always empty.","type":"text"}],"kind":"symbol","navigatorTitle":[{"text":"EmptyCollection","kind":"identifier"}],"title":"EmptyCollection","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/EmptyCollection","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/BinaryInteger":{"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"BinaryInteger"}],"navigatorTitle":[{"kind":"identifier","text":"BinaryInteger"}],"url":"\/documentation\/compute\/binaryinteger","type":"topic","abstract":[{"type":"text","text":"An integer type with a binary representation."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryInteger","title":"BinaryInteger","kind":"symbol","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/OpaquePointer":{"role":"symbol","navigatorTitle":[{"text":"OpaquePointer","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OpaquePointer","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/OpaquePointer","type":"topic","title":"OpaquePointer","kind":"symbol","abstract":[{"type":"text","text":"A wrapper around an opaque C pointer."}],"url":"\/documentation\/compute\/opaquepointer"},"doc://com.swallow.documentation.Compute/documentation/Compute/InstantProtocol":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/InstantProtocol","abstract":[],"url":"\/documentation\/compute\/instantprotocol","kind":"symbol","title":"InstantProtocol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"InstantProtocol","kind":"identifier"}],"type":"topic","role":"symbol","navigatorTitle":[{"text":"InstantProtocol","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD8":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD8","title":"SIMD8","abstract":[{"text":"A vector of eight scalar values.","type":"text"}],"kind":"symbol","navigatorTitle":[{"text":"SIMD8","kind":"identifier"}],"type":"topic","url":"\/documentation\/compute\/simd8","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"SIMD8","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ArrayTreeChildren":{"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"TreeValue","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":"."}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"url":"\/documentation\/compute\/arraytreechildren","role":"symbol","title":"ArrayTreeChildren","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ArrayTreeChildren","kind":"identifier"}],"abstract":[],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ArrayTreeChildren","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ArrayTreeChildren"}],"kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Bool":{"url":"\/documentation\/compute\/bool","role":"symbol","title":"Bool","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Bool","kind":"identifier"}],"abstract":[{"type":"text","text":"A value type whose instances are either "},{"type":"codeVoice","code":"true"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"false"},{"text":".","type":"text"}],"navigatorTitle":[{"text":"Bool","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Bool","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int64":{"url":"\/documentation\/compute\/int64","title":"Int64","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int64","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Int64"}],"abstract":[{"type":"text","text":"A 64-bit signed integer value"},{"text":" ","type":"text"},{"text":"type.","type":"text"}],"navigatorTitle":[{"text":"Int64","kind":"identifier"}],"type":"topic","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD32":{"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"SIMD32","kind":"identifier"}],"title":"SIMD32","navigatorTitle":[{"kind":"identifier","text":"SIMD32"}],"type":"topic","abstract":[{"type":"text","text":"A vector of 32 scalar values."}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD32","url":"\/documentation\/compute\/simd32","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/BidirectionalMap":{"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BidirectionalMap","url":"\/documentation\/compute\/bidirectionalmap","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"BidirectionalMap"}],"navigatorTitle":[{"text":"BidirectionalMap","kind":"identifier"}],"title":"BidirectionalMap","abstract":[{"type":"text","text":"A bidirectional map between two "},{"type":"codeVoice","code":"Hashable"},{"text":" types.","type":"text"}],"kind":"symbol","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Left"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Right"},{"type":"text","text":" conforms to "},{"code":"Hashable","type":"codeVoice"},{"text":".","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingDictionary/Difference":{"abstract":[],"title":"BranchingDictionary.Difference","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Difference"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/Difference","url":"\/documentation\/compute\/branchingdictionary\/difference","navigatorTitle":[{"text":"Difference","kind":"identifier"}],"kind":"symbol","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Branch"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":", "},{"type":"codeVoice","code":"Key"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Value"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/Matrix":{"type":"topic","role":"symbol","navigatorTitle":[{"text":"Matrix","kind":"identifier"}],"kind":"symbol","title":"Matrix","abstract":[],"url":"\/documentation\/compute\/matrix","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Matrix","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Element"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Matrix"},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingArray/Difference":{"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Branch"},{"type":"text","text":" conforms to "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Element","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Equatable","type":"codeVoice"},{"text":".","type":"text"}]},"kind":"symbol","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Difference","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/Difference","url":"\/documentation\/compute\/branchingarray\/difference","title":"BranchingArray.Difference","abstract":[],"navigatorTitle":[{"kind":"identifier","text":"Difference"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Int128":{"url":"\/documentation\/compute\/int128","abstract":[{"type":"text","text":"A 128-bit signed integer type."}],"title":"Int128","role":"symbol","navigatorTitle":[{"text":"Int128","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int128","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Int128"}],"kind":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int16":{"title":"Int16","abstract":[{"text":"A 16-bit signed integer value","type":"text"},{"type":"text","text":" "},{"text":"type.","type":"text"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int16","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Int16"}],"type":"topic","url":"\/documentation\/compute\/int16","navigatorTitle":[{"kind":"identifier","text":"Int16"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Unicode/UTF32":{"role":"symbol","abstract":[],"url":"\/documentation\/compute\/unicode\/utf32","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/UTF32","title":"Unicode.UTF32","type":"topic","navigatorTitle":[{"text":"UTF32","kind":"identifier"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"text":"UTF32","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ReferenceWritableKeyPath":{"title":"ReferenceWritableKeyPath","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"text":"ReferenceWritableKeyPath","kind":"identifier"}],"navigatorTitle":[{"text":"ReferenceWritableKeyPath","kind":"identifier"}],"url":"\/documentation\/compute\/referencewritablekeypath","abstract":[{"type":"text","text":"A key path that supports reading from and writing to the resulting value"},{"text":" ","type":"text"},{"text":"with reference semantics.","type":"text"}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReferenceWritableKeyPath","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/CollectionDifference/Change":{"type":"topic","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Change","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference\/Change","url":"\/documentation\/compute\/collectiondifference\/change","abstract":[{"type":"text","text":"A single change to a collection."}],"title":"CollectionDifference.Change","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"ChangeElement","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}]},"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Change"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Mirror/DisplayStyle-swift.enum":{"fragments":[{"text":"enum","kind":"keyword"},{"kind":"text","text":" "},{"text":"DisplayStyle","kind":"identifier"}],"role":"symbol","url":"\/documentation\/compute\/mirror\/displaystyle-swift.enum","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Mirror\/DisplayStyle-swift.enum","abstract":[{"text":"A suggestion of how a mirror’s subject is to be interpreted.","type":"text"}],"kind":"symbol","title":"Mirror.DisplayStyle","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DisplayStyle"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt16":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"UInt16","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"UInt16"}],"title":"UInt16","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt16","url":"\/documentation\/compute\/uint16","kind":"symbol","role":"symbol","abstract":[{"text":"A 16-bit unsigned integer value","type":"text"},{"text":" ","type":"text"},{"text":"type.","type":"text"}],"type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/ReversedCollection/Index":{"type":"topic","role":"symbol","navigatorTitle":[{"text":"Index","kind":"identifier"}],"kind":"symbol","title":"ReversedCollection.Index","abstract":[{"type":"text","text":"An index that traverses the same positions as an underlying index,"},{"text":" ","type":"text"},{"type":"text","text":"with inverted traversal direction."}],"url":"\/documentation\/compute\/reversedcollection\/index","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Index"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Base"},{"type":"text","text":" conforms to "},{"code":"BidirectionalCollection","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Base.Index","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReversedCollection\/Index"},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingDictionary/CommitID":{"type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"CommitID"}],"url":"\/documentation\/compute\/branchingdictionary\/commitid","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"CommitID","kind":"identifier"}],"abstract":[],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/CommitID","title":"BranchingDictionary.CommitID","conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Branch","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"Hashable","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Key"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Value"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/PartialKeyPath":{"type":"topic","navigatorTitle":[{"text":"PartialKeyPath","kind":"identifier"}],"abstract":[{"type":"text","text":"A partially type-erased key path, from a concrete root type to any"},{"text":" ","type":"text"},{"type":"text","text":"resulting value type."}],"title":"PartialKeyPath","url":"\/documentation\/compute\/partialkeypath","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/PartialKeyPath","role":"symbol","kind":"symbol","fragments":[{"text":"class","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"PartialKeyPath"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/CollectionDifference/Index":{"type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Index"}],"kind":"symbol","title":"CollectionDifference.Index","abstract":[{"type":"text","text":"The position of a collection difference."}],"url":"\/documentation\/compute\/collectiondifference\/index","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"ChangeElement","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Copyable"},{"type":"text","text":" and "},{"code":"Escapable","type":"codeVoice"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference\/Index"},"doc://com.swallow.documentation.Compute/documentation/Compute/Float":{"type":"topic","abstract":[{"text":"A single-precision, floating-point value type.","type":"text"}],"url":"\/documentation\/compute\/float","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Float"}],"navigatorTitle":[{"text":"Float","kind":"identifier"}],"title":"Float"},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD16":{"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"SIMD16","kind":"identifier"}],"type":"topic","title":"SIMD16","url":"\/documentation\/compute\/simd16","navigatorTitle":[{"kind":"identifier","text":"SIMD16"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD16","kind":"symbol","role":"symbol","abstract":[{"text":"A vector of 16 scalar values.","type":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute","url":"\/documentation\/compute","role":"collection","kind":"symbol","abstract":[],"type":"topic","title":"Compute"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafeRawPointer":{"role":"symbol","abstract":[{"text":"A raw pointer for accessing untyped data.","type":"text"}],"title":"UnsafeRawPointer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnsafeRawPointer"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeRawPointer","kind":"symbol","navigatorTitle":[{"text":"UnsafeRawPointer","kind":"identifier"}],"url":"\/documentation\/compute\/unsaferawpointer","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMDMask":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"SIMDMask"}],"role":"symbol","title":"SIMDMask","abstract":[],"url":"\/documentation\/compute\/simdmask","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMDMask","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SIMDMask"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/DurationProtocol":{"url":"\/documentation\/compute\/durationprotocol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"DurationProtocol"}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DurationProtocol","title":"DurationProtocol","role":"symbol","abstract":[{"text":"A type that defines a duration for a given ","type":"text"},{"type":"codeVoice","code":"InstantProtocol"},{"text":" type.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"DurationProtocol"}],"kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/RangeSet/Ranges-swift.struct":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Ranges"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Bound","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" and "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":"."}]},"abstract":[{"type":"text","text":"A collection of the ranges that make up a range set."}],"title":"RangeSet.Ranges","url":"\/documentation\/compute\/rangeset\/ranges-swift.struct","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/RangeSet\/Ranges-swift.struct","role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Ranges","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/SIMD2":{"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"SIMD2"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SIMD2","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"SIMD2"}],"abstract":[{"text":"A vector of two scalar values.","type":"text"}],"title":"SIMD2","url":"\/documentation\/compute\/simd2","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int32":{"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Int32","kind":"identifier"}],"abstract":[{"text":"A 32-bit signed integer value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"type."}],"kind":"symbol","navigatorTitle":[{"text":"Int32","kind":"identifier"}],"type":"topic","url":"\/documentation\/compute\/int32","title":"Int32","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int32"},"doc://com.swallow.documentation.Compute/documentation/Compute/AnyKeyPath":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyKeyPath","url":"\/documentation\/compute\/anykeypath","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"AnyKeyPath","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"AnyKeyPath"}],"role":"symbol","kind":"symbol","abstract":[{"text":"A type-erased key path, from any root type to any resulting value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"type."}],"type":"topic","title":"AnyKeyPath"},"doc://com.swallow.documentation.Compute/documentation/Compute/Set":{"title":"Set","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Set","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Set","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Set"}],"abstract":[{"type":"text","text":"An unordered collection of unique elements."}],"conformance":{"constraints":[{"code":"Element","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}]},"role":"symbol","kind":"symbol","url":"\/documentation\/compute\/set"},"doc://com.swallow.documentation.Compute/documentation/Compute/FloatingPointSign":{"url":"\/documentation\/compute\/floatingpointsign","title":"FloatingPointSign","abstract":[{"text":"The sign of a floating-point value.","type":"text"}],"role":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"FloatingPointSign"}],"navigatorTitle":[{"kind":"identifier","text":"FloatingPointSign"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPointSign","type":"topic","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnicodeDecodingResult":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnicodeDecodingResult","title":"UnicodeDecodingResult","abstract":[{"text":"The result of one Unicode decoding step.","type":"text"}],"type":"topic","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"UnicodeDecodingResult","kind":"identifier"}],"fragments":[{"text":"enum","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnicodeDecodingResult"}],"url":"\/documentation\/compute\/unicodedecodingresult"},"doc://com.swallow.documentation.Compute/documentation/Compute/Never":{"title":"Never","navigatorTitle":[{"kind":"identifier","text":"Never"}],"abstract":[{"type":"text","text":"A type that has no values and can’t be constructed."}],"kind":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Never"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Never","role":"symbol","type":"topic","url":"\/documentation\/compute\/never"},"doc://com.swallow.documentation.Compute/documentation/Compute/Dictionary/Index":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Index"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Key","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":", "},{"code":"Value","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Copyable","type":"codeVoice"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" conforms to "},{"code":"Escapable","type":"codeVoice"},{"type":"text","text":"."}]},"abstract":[{"type":"text","text":"The position of a key-value pair in a dictionary."}],"title":"Dictionary.Index","url":"\/documentation\/compute\/dictionary\/index","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary\/Index","role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/WritableKeyPath":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/WritableKeyPath","title":"WritableKeyPath","role":"symbol","abstract":[{"text":"A key path that supports reading from and writing to the resulting value.","type":"text"}],"type":"topic","kind":"symbol","navigatorTitle":[{"text":"WritableKeyPath","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"text":"WritableKeyPath","kind":"identifier"}],"url":"\/documentation\/compute\/writablekeypath"},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingDictionary/Difference/Insertion":{"navigatorTitle":[{"kind":"identifier","text":"Insertion"}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingDictionary\/Difference\/Insertion","url":"\/documentation\/compute\/branchingdictionary\/difference\/insertion","title":"BranchingDictionary.Difference.Insertion","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Insertion"}],"abstract":[],"type":"topic","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt":{"kind":"symbol","navigatorTitle":[{"text":"UInt","kind":"identifier"}],"type":"topic","title":"UInt","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt","abstract":[{"text":"An unsigned integer value type.","type":"text"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"UInt","kind":"identifier"}],"url":"\/documentation\/compute\/uint"},"doc://com.swallow.documentation.Compute/documentation/Compute/StringProtocol":{"url":"\/documentation\/compute\/stringprotocol","role":"symbol","abstract":[{"type":"text","text":"A type that can represent a string as a collection of characters."}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/StringProtocol","title":"StringProtocol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"StringProtocol","kind":"identifier"}],"navigatorTitle":[{"text":"StringProtocol","kind":"identifier"}],"kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt32":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt32","title":"UInt32","abstract":[{"type":"text","text":"A 32-bit unsigned integer value"},{"type":"text","text":" "},{"text":"type.","type":"text"}],"kind":"symbol","navigatorTitle":[{"text":"UInt32","kind":"identifier"}],"url":"\/documentation\/compute\/uint32","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"UInt32","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Double":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Double","abstract":[{"text":"A double-precision, floating-point value type.","type":"text"}],"title":"Double","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Double","kind":"identifier"}],"role":"symbol","navigatorTitle":[{"text":"Double","kind":"identifier"}],"kind":"symbol","type":"topic","url":"\/documentation\/compute\/double"},"doc://com.swallow.documentation.Compute/documentation/Compute/ManagedBufferPointer":{"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"ManagedBufferPointer"}],"abstract":[{"type":"text","text":"Contains a buffer object, and provides access to an instance of"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Header"},{"type":"text","text":" and contiguous storage for an arbitrary number of"},{"type":"text","text":" "},{"type":"codeVoice","code":"Element"},{"text":" instances stored in that buffer.","type":"text"}],"navigatorTitle":[{"text":"ManagedBufferPointer","kind":"identifier"}],"type":"topic","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ManagedBufferPointer","conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Header","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Copyable","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"Header"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":", "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" conforms to "},{"code":"Copyable","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Element","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"Escapable","type":"codeVoice"},{"text":".","type":"text"}]},"title":"ManagedBufferPointer","url":"\/documentation\/compute\/managedbufferpointer","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Array":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Array","kind":"identifier"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"Element","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}]},"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Array"}],"title":"Array","url":"\/documentation\/compute\/array","kind":"symbol","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Array","abstract":[{"type":"text","text":"An ordered, random-access collection."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafeMutablePointer":{"title":"UnsafeMutablePointer","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutablePointer","type":"topic","url":"\/documentation\/compute\/unsafemutablepointer","kind":"symbol","abstract":[{"text":"A pointer for accessing and manipulating data of a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"specific type."}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"UnsafeMutablePointer"}],"navigatorTitle":[{"text":"UnsafeMutablePointer","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Pointee","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Escapable","type":"codeVoice"},{"type":"text","text":"."}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsignedInteger":{"url":"\/documentation\/compute\/unsignedinteger","abstract":[{"type":"text","text":"An integer type that can represent only nonnegative values."}],"kind":"symbol","navigatorTitle":[{"text":"UnsignedInteger","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsignedInteger","title":"UnsignedInteger","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnsignedInteger"}],"type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/String":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"String"}],"title":"String","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"String","kind":"identifier"}],"abstract":[{"type":"text","text":"A Unicode string value that is a collection of characters."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String","kind":"symbol","role":"symbol","url":"\/documentation\/compute\/string"},"doc://com.swallow.documentation.Compute/documentation/Compute/Unicode/NumericType":{"navigatorTitle":[{"text":"NumericType","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/NumericType","kind":"symbol","title":"Unicode.NumericType","fragments":[{"kind":"keyword","text":"enum"},{"text":" ","kind":"text"},{"text":"NumericType","kind":"identifier"}],"url":"\/documentation\/compute\/unicode\/numerictype","role":"symbol","abstract":[{"type":"text","text":"The numeric type of a scalar."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/RangeSet":{"type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"RangeSet"}],"kind":"symbol","title":"RangeSet","abstract":[{"type":"text","text":"A set of values of any comparable type, represented by ranges."}],"url":"\/documentation\/compute\/rangeset","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"RangeSet","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Bound","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" and "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/RangeSet"},"doc://com.swallow.documentation.Compute/documentation/Compute/simd-swift.module.extension/simd_quatd":{"abstract":[],"title":"simd_quatd","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/simd-swift.module.extension\/simd_quatd","url":"\/documentation\/compute\/simd-swift.module.extension\/simd_quatd","fragments":[{"text":"extension","kind":"keyword"},{"text":" ","kind":"text"},{"text":"simd","kind":"identifier"},{"text":".","kind":"text"},{"preciseIdentifier":"c:@SA@simd_quatd","text":"simd_quatd","kind":"identifier"}],"kind":"symbol","role":"symbol","navigatorTitle":[{"text":"simd_quatd","kind":"identifier"}],"type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/Dictionary":{"type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Dictionary"}],"kind":"symbol","title":"Dictionary","abstract":[{"type":"text","text":"A collection whose elements are key-value pairs."}],"url":"\/documentation\/compute\/dictionary","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Dictionary","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Key","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" and "},{"code":"Value","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Hashable","type":"codeVoice"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary"},"doc://com.swallow.documentation.Compute/documentation/Compute/SignedNumeric":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SignedNumeric","url":"\/documentation\/compute\/signednumeric","title":"SignedNumeric","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"SignedNumeric"}],"navigatorTitle":[{"text":"SignedNumeric","kind":"identifier"}],"abstract":[{"type":"text","text":"A numeric type with a negation operation."}],"kind":"symbol","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/ClosedRange":{"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"ClosedRange","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ClosedRange","navigatorTitle":[{"text":"ClosedRange","kind":"identifier"}],"title":"ClosedRange","url":"\/documentation\/compute\/closedrange","abstract":[{"text":"An interval from a lower bound up to, and including, an upper bound.","type":"text"}],"role":"symbol","type":"topic","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Bound"},{"type":"text","text":" conforms to "},{"code":"Comparable","type":"codeVoice"},{"text":".","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/OptionSet":{"role":"symbol","url":"\/documentation\/compute\/optionset","type":"topic","abstract":[{"type":"text","text":"A type that presents a mathematical set interface to a bit set."}],"kind":"symbol","title":"OptionSet","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"OptionSet","kind":"identifier"}],"navigatorTitle":[{"text":"OptionSet","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/OptionSet"},"doc://com.swallow.documentation.Compute/documentation/Compute/Hashable":{"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Hashable"}],"title":"Hashable","navigatorTitle":[{"text":"Hashable","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"A type that can be hashed into a "},{"type":"codeVoice","code":"Hasher"},{"type":"text","text":" to produce an integer hash value."}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Hashable","url":"\/documentation\/compute\/hashable","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Unicode/Scalar":{"title":"Unicode.Scalar","type":"topic","kind":"symbol","navigatorTitle":[{"text":"Scalar","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Scalar","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/Scalar","abstract":[{"type":"text","text":"A Unicode scalar value."}],"role":"symbol","url":"\/documentation\/compute\/unicode\/scalar"},"doc://com.swallow.documentation.Compute/documentation/Compute/ArrayTree":{"type":"topic","role":"symbol","navigatorTitle":[{"text":"ArrayTree","kind":"identifier"}],"kind":"symbol","title":"ArrayTree","abstract":[],"url":"\/documentation\/compute\/arraytree","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"ArrayTree","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"T"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ArrayTree"},"doc://com.swallow.documentation.Compute/documentation/Compute/Equatable/==(_:_:)-3axv1":{"type":"topic","defaultImplementations":5,"abstract":[{"type":"text","text":"Returns a Boolean value indicating whether two values are equal."}],"kind":"symbol","title":"==(_:_:)","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable\/==(_:_:)-3axv1","required":true,"role":"symbol","url":"\/documentation\/compute\/equatable\/==(_:_:)-3axv1","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"=="},{"kind":"text","text":" "},{"kind":"text","text":"("},{"text":"Self","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/FloatingPointClassification":{"url":"\/documentation\/compute\/floatingpointclassification","fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FloatingPointClassification","kind":"identifier"}],"title":"FloatingPointClassification","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPointClassification","abstract":[{"text":"The IEEE 754 floating-point classes.","type":"text"}],"kind":"symbol","navigatorTitle":[{"text":"FloatingPointClassification","kind":"identifier"}],"type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/DiscontiguousSlice":{"type":"topic","role":"symbol","navigatorTitle":[{"text":"DiscontiguousSlice","kind":"identifier"}],"kind":"symbol","title":"DiscontiguousSlice","abstract":[{"type":"text","text":"A collection wrapper that provides access to the elements of a collection,"},{"text":" ","type":"text"},{"type":"text","text":"indexed by a set of indices."}],"url":"\/documentation\/compute\/discontiguousslice","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"DiscontiguousSlice"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Base"},{"type":"text","text":" conforms to "},{"code":"Collection","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Base.Element","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DiscontiguousSlice"},"doc://com.swallow.documentation.Compute/documentation/Compute/AnyHashable":{"role":"symbol","type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"AnyHashable","kind":"identifier"}],"abstract":[{"text":"A type-erased hashable value.","type":"text"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyHashable","navigatorTitle":[{"text":"AnyHashable","kind":"identifier"}],"url":"\/documentation\/compute\/anyhashable","title":"AnyHashable","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/ReferenceTree":{"fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ReferenceTree","kind":"identifier"}],"abstract":[{"type":"text","text":"A simple reference-based tree data structure for Swift."}],"navigatorTitle":[{"kind":"identifier","text":"ReferenceTree"}],"type":"topic","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReferenceTree","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"Element","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}]},"title":"ReferenceTree","url":"\/documentation\/compute\/referencetree","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Numeric":{"abstract":[{"type":"text","text":"A type with values that support multiplication."}],"kind":"symbol","url":"\/documentation\/compute\/numeric","navigatorTitle":[{"text":"Numeric","kind":"identifier"}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Numeric","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Numeric"}],"title":"Numeric"},"doc://com.swallow.documentation.Compute/documentation/Compute/LinkedList":{"abstract":[],"title":"LinkedList","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"LinkedList"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/LinkedList","role":"symbol","url":"\/documentation\/compute\/linkedlist","navigatorTitle":[{"text":"LinkedList","kind":"identifier"}],"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Element"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/Optional":{"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Optional","kind":"identifier"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"Wrapped","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":"."}]},"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Optional"}],"title":"Optional","url":"\/documentation\/compute\/optional","kind":"symbol","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Optional","abstract":[{"type":"text","text":"A type that represents either a wrapped value or the absence of a value."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Duration":{"abstract":[{"type":"text","text":"A representation of high precision time."}],"type":"topic","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Duration","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Duration"}],"url":"\/documentation\/compute\/duration","navigatorTitle":[{"kind":"identifier","text":"Duration"}],"title":"Duration","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/BranchingArray/Difference/Insertion":{"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Insertion","kind":"identifier"}],"url":"\/documentation\/compute\/branchingarray\/difference\/insertion","navigatorTitle":[{"text":"Insertion","kind":"identifier"}],"abstract":[],"title":"BranchingArray.Difference.Insertion","kind":"symbol","type":"topic","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BranchingArray\/Difference\/Insertion"},"doc://com.swallow.documentation.Compute/documentation/Compute/AdditiveArithmetic":{"type":"topic","title":"AdditiveArithmetic","abstract":[{"text":"A type with values that support addition and subtraction.","type":"text"}],"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"AdditiveArithmetic"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AdditiveArithmetic","url":"\/documentation\/compute\/additivearithmetic","role":"symbol","navigatorTitle":[{"text":"AdditiveArithmetic","kind":"identifier"}]}}}