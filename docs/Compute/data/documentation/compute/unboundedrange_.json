{"topicSections":[{"generated":true,"title":"Operators","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnboundedRange_\/...(_:)"],"anchor":"Operators"}],"identifier":{"url":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnboundedRange_","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute"]]},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/compute\/unboundedrange_"]}],"schemaVersion":{"minor":3,"patch":0,"major":0},"abstract":[{"text":"A range expression that represents the entire range of a collection.","type":"text"}],"kind":"symbol","relationshipsSections":[{"identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BitwiseCopyable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Copyable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Sendable"],"type":"conformsTo","kind":"relationships","title":"Conforms To"}],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"attribute","text":"@frozen"},{"text":" ","kind":"text"},{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"text":"UnboundedRange_","kind":"identifier"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"text":"Overview","level":2,"type":"heading","anchor":"overview"},{"type":"paragraph","inlineContent":[{"text":"You can use the unbounded range operator (","type":"text"},{"type":"codeVoice","code":"..."},{"type":"text","text":") to create a slice of a"},{"text":" ","type":"text"},{"text":"collection that contains all of the collection’s elements. Slicing with an","type":"text"},{"type":"text","text":" "},{"type":"text","text":"unbounded range is essentially a conversion of a collection instance into"},{"type":"text","text":" "},{"text":"its slice type.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"For example, the following code declares ","type":"text"},{"code":"countLetterChanges(_:_:)","type":"codeVoice"},{"type":"text","text":", a"},{"text":" ","type":"text"},{"type":"text","text":"function that finds the number of changes required to change one"},{"text":" ","type":"text"},{"text":"word or phrase into another. The function uses a recursive approach to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"perform the same comparisons on smaller and smaller pieces of the original"},{"type":"text","text":" "},{"text":"strings. In order to use recursion without making copies of the strings at","type":"text"},{"type":"text","text":" "},{"text":"each step, ","type":"text"},{"code":"countLetterChanges(_:_:)","type":"codeVoice"},{"text":" uses ","type":"text"},{"code":"Substring","type":"codeVoice"},{"text":", a string’s slice","type":"text"},{"text":" ","type":"text"},{"text":"type, for its parameters.","type":"text"}]},{"type":"codeListing","syntax":null,"code":["func countLetterChanges(_ s1: Substring, _ s2: Substring) -> Int {","    if s1.isEmpty { return s2.count }","    if s2.isEmpty { return s1.count }","","    let cost = s1.first == s2.first ? 0 : 1","","    return min(","        countLetterChanges(s1.dropFirst(), s2) + 1,","        countLetterChanges(s1, s2.dropFirst()) + 1,","        countLetterChanges(s1.dropFirst(), s2.dropFirst()) + cost)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To call "},{"type":"codeVoice","code":"countLetterChanges(_:_:)"},{"type":"text","text":" with two strings, use an unbounded"},{"type":"text","text":" "},{"text":"range in each string’s subscript.","type":"text"}]},{"type":"codeListing","syntax":null,"code":["let word1 = \"grizzly\"","let word2 = \"grisly\"","let changes = countLetterChanges(word1[...], word2[...])","\/\/ changes == 2"]}]}],"metadata":{"title":"UnboundedRange_","fragments":[{"kind":"keyword","text":"enum"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnboundedRange_"}],"externalID":"s:s15UnboundedRange_O","navigatorTitle":[{"text":"UnboundedRange_","kind":"identifier"}],"symbolKind":"enum","role":"symbol","modules":[{"name":"Compute"}],"roleHeading":"Enumeration"},"sections":[],"references":{"doc://com.swallow.documentation.Compute/documentation/Compute/Copyable":{"title":"Copyable","abstract":[{"type":"text","text":"A type whose values can be implicitly or explicitly copied."}],"fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"Copyable","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Copyable","url":"\/documentation\/compute\/copyable","navigatorTitle":[{"text":"Copyable","kind":"identifier"}],"kind":"symbol","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/BitwiseCopyable":{"title":"BitwiseCopyable","abstract":[],"fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BitwiseCopyable","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BitwiseCopyable","url":"\/documentation\/compute\/bitwisecopyable","navigatorTitle":[{"kind":"identifier","text":"BitwiseCopyable"}],"kind":"symbol","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/Sendable":{"kind":"symbol","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Sendable","kind":"identifier"}],"title":"Sendable","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Sendable","abstract":[],"url":"\/documentation\/compute\/sendable","role":"symbol","navigatorTitle":[{"text":"Sendable","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnboundedRange_/...(_:)":{"title":"...(_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"text":"...","kind":"identifier"},{"text":" ","kind":"text"},{"text":"(","kind":"text"},{"preciseIdentifier":"s:s15UnboundedRange_O","text":"UnboundedRange_","kind":"typeIdentifier"},{"text":")","kind":"text"}],"url":"\/documentation\/compute\/unboundedrange_\/'...(_:)","abstract":[{"type":"text","text":"Creates an unbounded range expression."}],"kind":"symbol","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnboundedRange_\/...(_:)","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnboundedRange_":{"type":"topic","url":"\/documentation\/compute\/unboundedrange_","role":"symbol","kind":"symbol","fragments":[{"text":"enum","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnboundedRange_"}],"abstract":[{"type":"text","text":"A range expression that represents the entire range of a collection."}],"navigatorTitle":[{"kind":"identifier","text":"UnboundedRange_"}],"title":"UnboundedRange_","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnboundedRange_"},"doc://com.swallow.documentation.Compute/documentation/Compute":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute","url":"\/documentation\/compute","role":"collection","kind":"symbol","abstract":[],"type":"topic","title":"Compute"}}}