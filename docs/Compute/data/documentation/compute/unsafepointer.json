{"sections":[],"abstract":[{"text":"A pointer for accessing data of a specific type.","type":"text"}],"relationshipsSections":[{"kind":"relationships","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BitwiseCopyable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CVarArg","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Copyable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CustomDebugStringConvertible","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CustomReflectable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Hashable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Strideable","doc:\/\/com.swallow.documentation.Compute\/7Swallow21BitPatternConvertibleP","doc:\/\/com.swallow.documentation.Compute\/7Swallow20ByteTupleConvertibleP","doc:\/\/com.swallow.documentation.Compute\/7Swallow15ConstantPointerP","doc:\/\/com.swallow.documentation.Compute\/7Swallow32MutableRepresentationConvertibleP","doc:\/\/com.swallow.documentation.Compute\/7Swallow15NativeWordSizedP","doc:\/\/com.swallow.documentation.Compute\/7Swallow22OpaquePointerInitiableP","doc:\/\/com.swallow.documentation.Compute\/7Swallow7PointerP","doc:\/\/com.swallow.documentation.Compute\/7Swallow7TrivialP"],"title":"Conforms To","type":"conformsTo"}],"schemaVersion":{"patch":0,"major":0,"minor":3},"kind":"symbol","topicSections":[{"identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/pointee"],"generated":true,"anchor":"Instance-Properties","title":"Instance Properties"},{"identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/deallocate()","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/pointer(to:)","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/withMemoryRebound(to:capacity:_:)"],"title":"Instance Methods","anchor":"Instance-Methods","generated":true},{"anchor":"Subscripts","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/subscript(_:)"],"title":"Subscripts","generated":true},{"title":"Type Aliases","generated":true,"anchor":"Type-Aliases","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Distance"]},{"title":"Default Implementations","anchor":"Default-Implementations","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Comparable-Implementations","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/CustomReflectable-Implementations","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Equatable-Implementations","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Hashable-Implementations","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Strideable-Implementations","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/_CustomPlaygroundQuickLookable-Implementations","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/_Pointer-Implementations"],"generated":true}],"hierarchy":{"paths":[["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer"},"primaryContentSections":[{"declarations":[{"languages":["swift"],"tokens":[{"text":"@frozen","kind":"attribute"},{"kind":"text","text":" "},{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnsafePointer"},{"text":"<","kind":"text"},{"text":"Pointee","kind":"genericParameter"},{"kind":"text","text":"> "},{"text":"where","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"typeIdentifier","text":"Pointee"},{"text":" : ~Copyable","kind":"text"}],"platforms":["macOS"]}],"kind":"declarations"},{"content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"You use instances of the ","type":"text"},{"type":"codeVoice","code":"UnsafePointer"},{"text":" type to access data of a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"specific type in memory. The type of data that a pointer can access is the"},{"type":"text","text":" "},{"text":"pointer’s ","type":"text"},{"type":"codeVoice","code":"Pointee"},{"text":" type. ","type":"text"},{"code":"UnsafePointer","type":"codeVoice"},{"type":"text","text":" provides no automated"},{"type":"text","text":" "},{"type":"text","text":"memory management or alignment guarantees. You are responsible for"},{"text":" ","type":"text"},{"text":"handling the life cycle of any memory you work with through unsafe","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"pointers to avoid leaks or undefined behavior."}]},{"inlineContent":[{"text":"Memory that you manually manage can be either ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"untyped","type":"text"}]},{"text":" or ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"bound"}]},{"type":"text","text":" to a"},{"type":"text","text":" "},{"type":"text","text":"specific type. You use the "},{"type":"codeVoice","code":"UnsafePointer"},{"type":"text","text":" type to access and"},{"type":"text","text":" "},{"text":"manage memory that has been bound to a specific type.","type":"text"}],"type":"paragraph"},{"level":1,"text":"Understanding a Pointer’s Memory State","type":"heading","anchor":"Understanding-a-Pointers-Memory-State"},{"inlineContent":[{"text":"The memory referenced by an ","type":"text"},{"type":"codeVoice","code":"UnsafePointer"},{"type":"text","text":" instance can be in"},{"type":"text","text":" "},{"type":"text","text":"one of several states. Many pointer operations must only be applied to"},{"type":"text","text":" "},{"text":"pointers with memory in a specific state—you must keep track of the","type":"text"},{"type":"text","text":" "},{"text":"state of the memory you are working with and understand the changes to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that state that different operations perform. Memory can be untyped and"},{"type":"text","text":" "},{"text":"uninitialized, bound to a type and uninitialized, or bound to a type and","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"initialized to a value. Finally, memory that was allocated previously may"},{"type":"text","text":" "},{"type":"text","text":"have been deallocated, leaving existing pointers referencing unallocated"},{"text":" ","type":"text"},{"type":"text","text":"memory."}],"type":"paragraph"},{"anchor":"Uninitialized-Memory","text":"Uninitialized Memory","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Memory that has just been allocated through a typed pointer or has been","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"deinitialized is in an "},{"inlineContent":[{"type":"text","text":"uninitialized"}],"type":"emphasis"},{"type":"text","text":" state. Uninitialized memory must be"},{"text":" ","type":"text"},{"type":"text","text":"initialized before it can be accessed for reading."}]},{"type":"heading","anchor":"Initialized-Memory","text":"Initialized Memory","level":2},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Initialized","type":"text"}]},{"text":" memory has a value that can be read using a pointer’s","type":"text"},{"type":"text","text":" "},{"code":"pointee","type":"codeVoice"},{"type":"text","text":" property or through subscript notation. In the following"},{"type":"text","text":" "},{"text":"example, ","type":"text"},{"code":"ptr","type":"codeVoice"},{"text":" is a pointer to memory initialized with a value of ","type":"text"},{"type":"codeVoice","code":"23"},{"type":"text","text":":"}],"type":"paragraph"},{"code":["let ptr: UnsafePointer<Int> = ...","\/\/ ptr.pointee == 23","\/\/ ptr[0] == 23"],"type":"codeListing","syntax":null},{"text":"Accessing a Pointer’s Memory as a Different Type","type":"heading","level":1,"anchor":"Accessing-a-Pointers-Memory-as-a-Different-Type"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you access memory through an "},{"code":"UnsafePointer","type":"codeVoice"},{"text":" instance, the","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" type must be consistent with the bound type of the memory. If"},{"type":"text","text":" "},{"text":"you do need to access memory that is bound to one type as a different","type":"text"},{"type":"text","text":" "},{"text":"type, Swift’s pointer types provide type-safe ways to temporarily or","type":"text"},{"text":" ","type":"text"},{"text":"permanently change the bound type of the memory, or to load typed","type":"text"},{"type":"text","text":" "},{"type":"text","text":"instances directly from raw memory."}]},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"code":"UnsafePointer<UInt8>","type":"codeVoice"},{"type":"text","text":" instance allocated with eight bytes of"},{"type":"text","text":" "},{"type":"text","text":"memory, "},{"code":"uint8Pointer","type":"codeVoice"},{"type":"text","text":", will be used for the examples below."}]},{"syntax":null,"code":["let uint8Pointer: UnsafePointer<UInt8> = fetchEightBytes()"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"When you only need to temporarily access a pointer’s memory as a different"},{"type":"text","text":" "},{"text":"type, use the ","type":"text"},{"code":"withMemoryRebound(to:capacity:)","type":"codeVoice"},{"text":" method. For example, you","type":"text"},{"type":"text","text":" "},{"type":"text","text":"can use this method to call an API that expects a pointer to a different"},{"text":" ","type":"text"},{"text":"type that is layout compatible with your pointer’s ","type":"text"},{"type":"codeVoice","code":"Pointee"},{"text":". The following","type":"text"},{"type":"text","text":" "},{"text":"code temporarily rebinds the memory that ","type":"text"},{"type":"codeVoice","code":"uint8Pointer"},{"text":" references from","type":"text"},{"type":"text","text":" "},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" to "},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" to call the imported C "},{"type":"codeVoice","code":"strlen"},{"text":" function.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":null,"code":["\/\/ Imported from C","func strlen(_ __s: UnsafePointer<Int8>!) -> UInt","","let length = uint8Pointer.withMemoryRebound(to: Int8.self, capacity: 8) {","    return strlen($0)","}","\/\/ length == 7"]},{"inlineContent":[{"type":"text","text":"When you need to permanently rebind memory to a different type, first"},{"type":"text","text":" "},{"type":"text","text":"obtain a raw pointer to the memory and then call the"},{"type":"text","text":" "},{"type":"codeVoice","code":"bindMemory(to:capacity:)"},{"text":" method on the raw pointer. The following","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"example binds the memory referenced by "},{"code":"uint8Pointer","type":"codeVoice"},{"text":" to one instance of","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"UInt64"},{"text":" type:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let uint64Pointer = UnsafeRawPointer(uint8Pointer)","                          .bindMemory(to: UInt64.self, capacity: 1)"],"syntax":null},{"inlineContent":[{"text":"After rebinding the memory referenced by ","type":"text"},{"code":"uint8Pointer","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"UInt64","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"accessing that pointer’s referenced memory as a "},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" instance is"},{"text":" ","type":"text"},{"text":"undefined.","type":"text"}],"type":"paragraph"},{"code":["var fullInteger = uint64Pointer.pointee          \/\/ OK","var firstByte = uint8Pointer.pointee             \/\/ undefined"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"Alternatively, you can access the same memory as a different type without","type":"text"},{"type":"text","text":" "},{"type":"text","text":"rebinding through untyped memory access, so long as the bound type and the"},{"type":"text","text":" "},{"text":"destination type are trivial types. Convert your pointer to an","type":"text"},{"type":"text","text":" "},{"code":"UnsafeRawPointer","type":"codeVoice"},{"text":" instance and then use the raw pointer’s","type":"text"},{"text":" ","type":"text"},{"code":"load(fromByteOffset:as:)","type":"codeVoice"},{"text":" method to read values.","type":"text"}]},{"code":["let rawPointer = UnsafeRawPointer(uint64Pointer)","let fullInteger = rawPointer.load(as: UInt64.self)   \/\/ OK","let firstByte = rawPointer.load(as: UInt8.self)      \/\/ OK"],"syntax":null,"type":"codeListing"},{"text":"Performing Typed Pointer Arithmetic","level":1,"type":"heading","anchor":"Performing-Typed-Pointer-Arithmetic"},{"inlineContent":[{"type":"text","text":"Pointer arithmetic with a typed pointer is counted in strides of the"},{"type":"text","text":" "},{"text":"pointer’s ","type":"text"},{"code":"Pointee","type":"codeVoice"},{"text":" type. When you add to or subtract from an ","type":"text"},{"code":"UnsafePointer","type":"codeVoice"},{"text":" ","type":"text"},{"text":"instance, the result is a new pointer of the same type, offset by that","type":"text"},{"type":"text","text":" "},{"text":"number of instances of the ","type":"text"},{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" type."}],"type":"paragraph"},{"type":"codeListing","code":["\/\/ 'intPointer' points to memory initialized with [10, 20, 30, 40]","let intPointer: UnsafePointer<Int> = ...","","\/\/ Load the first value in memory","let x = intPointer.pointee","\/\/ x == 10","","\/\/ Load the third value in memory","let offsetPointer = intPointer + 2","let y = offsetPointer.pointee","\/\/ y == 30"],"syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also use subscript notation to access the value in memory at a"},{"type":"text","text":" "},{"text":"specific offset.","type":"text"}]},{"code":["let z = intPointer[2]","\/\/ z == 30"],"type":"codeListing","syntax":null},{"anchor":"Implicit-Casting-and-Bridging","level":1,"text":"Implicit Casting and Bridging","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"When calling a function or method with an ","type":"text"},{"code":"UnsafePointer","type":"codeVoice"},{"text":" parameter, you can pass","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an instance of that specific pointer type, pass an instance of a"},{"type":"text","text":" "},{"text":"compatible pointer type, or use Swift’s implicit bridging to pass a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"compatible pointer."}]},{"type":"paragraph","inlineContent":[{"text":"For example, the ","type":"text"},{"code":"printInt(atAddress:)","type":"codeVoice"},{"text":" function in the following code","type":"text"},{"type":"text","text":" "},{"text":"sample expects an ","type":"text"},{"type":"codeVoice","code":"UnsafePointer<Int>"},{"type":"text","text":" instance as its first parameter:"}]},{"code":["func printInt(atAddress p: UnsafePointer<Int>) {","    print(p.pointee)","}"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"text":"As is typical in Swift, you can call the ","type":"text"},{"code":"printInt(atAddress:)","type":"codeVoice"},{"type":"text","text":" function"},{"type":"text","text":" "},{"text":"with an ","type":"text"},{"type":"codeVoice","code":"UnsafePointer"},{"type":"text","text":" instance. This example passes "},{"code":"intPointer","type":"codeVoice"},{"type":"text","text":", a pointer to"},{"type":"text","text":" "},{"text":"an ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" value, to ","type":"text"},{"type":"codeVoice","code":"print(address:)"},{"text":".","type":"text"}]},{"syntax":null,"code":["printInt(atAddress: intPointer)","\/\/ Prints \"42\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Because a mutable typed pointer can be implicitly cast to an immutable"},{"text":" ","type":"text"},{"type":"text","text":"pointer with the same "},{"code":"Pointee","type":"codeVoice"},{"text":" type when passed as a parameter, you can","type":"text"},{"type":"text","text":" "},{"type":"text","text":"also call "},{"code":"printInt(atAddress:)","type":"codeVoice"},{"type":"text","text":" with an "},{"code":"UnsafeMutablePointer","type":"codeVoice"},{"text":" instance.","type":"text"}],"type":"paragraph"},{"code":["let mutableIntPointer = UnsafeMutablePointer(mutating: intPointer)","printInt(atAddress: mutableIntPointer)","\/\/ Prints \"42\""],"syntax":null,"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Alternatively, you can use Swift’s "},{"type":"emphasis","inlineContent":[{"type":"text","text":"implicit bridging"}]},{"type":"text","text":" to pass a pointer to"},{"text":" ","type":"text"},{"type":"text","text":"an instance or to the elements of an array. The following example passes a"},{"text":" ","type":"text"},{"type":"text","text":"pointer to the "},{"code":"value","type":"codeVoice"},{"text":" variable by using inout syntax:","type":"text"}],"type":"paragraph"},{"syntax":null,"type":"codeListing","code":["var value: Int = 23","printInt(atAddress: &value)","\/\/ Prints \"23\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An immutable pointer to the elements of an array is implicitly created when"},{"text":" ","type":"text"},{"type":"text","text":"you pass the array as an argument. This example uses implicit bridging to"},{"type":"text","text":" "},{"type":"text","text":"pass a pointer to the elements of "},{"type":"codeVoice","code":"numbers"},{"type":"text","text":" when calling"},{"text":" ","type":"text"},{"type":"codeVoice","code":"printInt(atAddress:)"},{"text":".","type":"text"}]},{"code":["let numbers = [5, 10, 15, 20]","printInt(atAddress: numbers)","\/\/ Prints \"5\""],"syntax":null,"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"You can also use inout syntax to pass a mutable pointer to the elements of","type":"text"},{"text":" ","type":"text"},{"text":"an array. Because ","type":"text"},{"type":"codeVoice","code":"printInt(atAddress:)"},{"type":"text","text":" requires an immutable pointer,"},{"text":" ","type":"text"},{"text":"although this is syntactically valid, it isn’t necessary.","type":"text"}]},{"syntax":null,"code":["var mutableNumbers = numbers","printInt(atAddress: &mutableNumbers)"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"No matter which way you call "},{"code":"printInt(atAddress:)","type":"codeVoice"},{"type":"text","text":", Swift’s type safety"},{"type":"text","text":" "},{"text":"guarantees that you can only pass a pointer to the type required by the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"function—in this case, a pointer to an "},{"code":"Int","type":"codeVoice"},{"type":"text","text":"."}]},{"style":"important","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The pointer created through implicit bridging of an instance"},{"text":" ","type":"text"},{"text":"or of an array’s elements is only valid during the execution of the","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"called function. Escaping the pointer to use after the execution of the"},{"type":"text","text":" "},{"text":"function is undefined behavior. In particular, do not use implicit","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"bridging when calling an "},{"code":"UnsafePointer","type":"codeVoice"},{"type":"text","text":" initializer."}]}],"name":"Important"}],"kind":"content"}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/compute\/unsafepointer"]}],"metadata":{"navigatorTitle":[{"kind":"identifier","text":"UnsafePointer"}],"role":"symbol","title":"UnsafePointer","externalID":"s:SP","modules":[{"name":"Compute"}],"roleHeading":"Structure","symbolKind":"struct","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"UnsafePointer","kind":"identifier"}]},"references":{"doc://com.swallow.documentation.Compute/7Swallow21BitPatternConvertibleP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow21BitPatternConvertibleP","title":"Swallow.BitPatternConvertible"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/Distance":{"type":"topic","abstract":[{"type":"text","text":"A type that represents the distance between two pointers."}],"kind":"symbol","title":"UnsafePointer.Distance","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Distance"}],"url":"\/documentation\/compute\/unsafepointer\/distance","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Distance","fragments":[{"text":"typealias","kind":"keyword"},{"kind":"text","text":" "},{"text":"Distance","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer":{"abstract":[{"type":"text","text":"A pointer for accessing data of a specific type."}],"type":"topic","title":"UnsafePointer","url":"\/documentation\/compute\/unsafepointer","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnsafePointer"}],"role":"symbol","navigatorTitle":[{"kind":"identifier","text":"UnsafePointer"}],"kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/pointee":{"role":"symbol","type":"topic","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/pointee","fragments":[{"text":"var","kind":"keyword"},{"kind":"text","text":" "},{"text":"pointee","kind":"identifier"},{"kind":"text","text":": "},{"text":"Pointee","kind":"typeIdentifier"}],"title":"pointee","url":"\/documentation\/compute\/unsafepointer\/pointee","abstract":[{"type":"text","text":"Accesses the instance referenced by this pointer."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/CustomDebugStringConvertible":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CustomDebugStringConvertible","abstract":[{"type":"text","text":"A type with a customized textual representation suitable for debugging"},{"type":"text","text":" "},{"type":"text","text":"purposes."}],"role":"symbol","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}]},"type":"topic","navigatorTitle":[{"text":"CustomDebugStringConvertible","kind":"identifier"}],"title":"CustomDebugStringConvertible","kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"CustomDebugStringConvertible","kind":"identifier"}],"url":"\/documentation\/compute\/customdebugstringconvertible"},"doc://com.swallow.documentation.Compute/documentation/Compute/CVarArg":{"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"CVarArg"}],"url":"\/documentation\/compute\/cvararg","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CVarArg","navigatorTitle":[{"text":"CVarArg","kind":"identifier"}],"abstract":[{"type":"text","text":"A type whose instances can be encoded, and appropriately passed, as"},{"type":"text","text":" "},{"type":"text","text":"elements of a C "},{"code":"va_list","type":"codeVoice"},{"type":"text","text":"."}],"title":"CVarArg","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/pointer(to:)":{"type":"topic","abstract":[{"type":"text","text":"Obtain a pointer to the stored property referred to by a key path."}],"kind":"symbol","title":"pointer(to:)","role":"symbol","url":"\/documentation\/compute\/unsafepointer\/pointer(to:)","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/pointer(to:)","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"pointer","kind":"identifier"},{"kind":"text","text":"<"},{"text":"Property","kind":"genericParameter"},{"text":">(","kind":"text"},{"kind":"externalParam","text":"to"},{"text":": ","kind":"text"},{"text":"KeyPath","kind":"typeIdentifier","preciseIdentifier":"s:s7KeyPathC"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Pointee"},{"kind":"text","text":", "},{"text":"Property","kind":"typeIdentifier"},{"text":">) -> ","kind":"text"},{"text":"UnsafePointer","kind":"typeIdentifier","preciseIdentifier":"s:SP"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Property"},{"text":">?","kind":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/Strideable-Implementations":{"abstract":[],"title":"Strideable Implementations","role":"collectionGroup","url":"\/documentation\/compute\/unsafepointer\/strideable-implementations","kind":"article","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Strideable-Implementations","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/Hashable":{"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Hashable","kind":"identifier"}],"url":"\/documentation\/compute\/hashable","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Hashable","navigatorTitle":[{"text":"Hashable","kind":"identifier"}],"abstract":[{"type":"text","text":"A type that can be hashed into a "},{"type":"codeVoice","code":"Hasher"},{"type":"text","text":" to produce an integer hash value."}],"title":"Hashable","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/CustomReflectable-Implementations":{"title":"CustomReflectable Implementations","abstract":[],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/CustomReflectable-Implementations","role":"collectionGroup","type":"topic","url":"\/documentation\/compute\/unsafepointer\/customreflectable-implementations","kind":"article"},"doc://com.swallow.documentation.Compute/documentation/Compute/CustomReflectable":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CustomReflectable","abstract":[{"type":"text","text":"A type that explicitly supplies its own mirror."}],"role":"symbol","conformance":{"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"type":"topic","navigatorTitle":[{"kind":"identifier","text":"CustomReflectable"}],"title":"CustomReflectable","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"CustomReflectable","kind":"identifier"}],"url":"\/documentation\/compute\/customreflectable"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/Hashable-Implementations":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Hashable-Implementations","abstract":[],"url":"\/documentation\/compute\/unsafepointer\/hashable-implementations","kind":"article","type":"topic","title":"Hashable Implementations","role":"collectionGroup"},"doc://com.swallow.documentation.Compute/7Swallow7TrivialP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow7TrivialP","title":"Swallow.Trivial"},"doc://com.swallow.documentation.Compute/7Swallow15ConstantPointerP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow15ConstantPointerP","title":"Swallow.ConstantPointer"},"doc://com.swallow.documentation.Compute/documentation/Compute/Copyable":{"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"Copyable","kind":"identifier"}],"url":"\/documentation\/compute\/copyable","conformance":{"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Copyable","navigatorTitle":[{"kind":"identifier","text":"Copyable"}],"abstract":[{"type":"text","text":"A type whose values can be implicitly or explicitly copied."}],"title":"Copyable","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/BitwiseCopyable":{"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"BitwiseCopyable","kind":"identifier"}],"url":"\/documentation\/compute\/bitwisecopyable","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BitwiseCopyable","navigatorTitle":[{"text":"BitwiseCopyable","kind":"identifier"}],"abstract":[],"title":"BitwiseCopyable","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/7Swallow7PointerP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow7PointerP","title":"Swallow.Pointer"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/deallocate()":{"type":"topic","abstract":[{"type":"text","text":"Deallocates the memory block previously allocated at this pointer."}],"kind":"symbol","title":"deallocate()","role":"symbol","url":"\/documentation\/compute\/unsafepointer\/deallocate()","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/deallocate()","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"deallocate","kind":"identifier"},{"kind":"text","text":"()"}]},"doc://com.swallow.documentation.Compute/7Swallow20ByteTupleConvertibleP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow20ByteTupleConvertibleP","title":"Swallow.ByteTupleConvertible"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/Equatable-Implementations":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Equatable-Implementations","abstract":[],"title":"Equatable Implementations","type":"topic","kind":"article","url":"\/documentation\/compute\/unsafepointer\/equatable-implementations","role":"collectionGroup"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/Comparable-Implementations":{"role":"collectionGroup","kind":"article","title":"Comparable Implementations","url":"\/documentation\/compute\/unsafepointer\/comparable-implementations","abstract":[],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/Comparable-Implementations"},"doc://com.swallow.documentation.Compute/7Swallow22OpaquePointerInitiableP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow22OpaquePointerInitiableP","title":"Swallow.OpaquePointerInitiable"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/_CustomPlaygroundQuickLookable-Implementations":{"role":"collectionGroup","type":"topic","kind":"article","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/_CustomPlaygroundQuickLookable-Implementations","title":"_CustomPlaygroundQuickLookable Implementations","url":"\/documentation\/compute\/unsafepointer\/_customplaygroundquicklookable-implementations","abstract":[]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/subscript(_:)":{"type":"topic","abstract":[{"type":"text","text":"Accesses the pointee at the specified offset from this pointer."}],"kind":"symbol","title":"subscript(_:)","role":"symbol","url":"\/documentation\/compute\/unsafepointer\/subscript(_:)","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/subscript(_:)","fragments":[{"text":"subscript","kind":"keyword"},{"kind":"text","text":"("},{"text":"Int","preciseIdentifier":"s:Si","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"text":"Pointee","kind":"typeIdentifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Equatable":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable","abstract":[{"type":"text","text":"A type that can be compared for value equality."}],"role":"symbol","conformance":{"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Equatable"}],"title":"Equatable","kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"Equatable","kind":"identifier"}],"url":"\/documentation\/compute\/equatable"},"doc://com.swallow.documentation.Compute/7Swallow15NativeWordSizedP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow15NativeWordSizedP","title":"Swallow.NativeWordSized"},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable":{"kind":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"Comparable","kind":"identifier"}],"url":"\/documentation\/compute\/comparable","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"code":"Pointee","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Escapable"},{"text":".","type":"text"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable","navigatorTitle":[{"kind":"identifier","text":"Comparable"}],"abstract":[{"type":"text","text":"A type that can be compared using the relational operators "},{"type":"codeVoice","code":"<"},{"type":"text","text":", "},{"code":"<=","type":"codeVoice"},{"type":"text","text":", "},{"code":">=","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":">"},{"type":"text","text":"."}],"title":"Comparable","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute","url":"\/documentation\/compute","role":"collection","kind":"symbol","abstract":[],"type":"topic","title":"Compute"},"doc://com.swallow.documentation.Compute/7Swallow32MutableRepresentationConvertibleP":{"type":"unresolvable","identifier":"doc:\/\/com.swallow.documentation.Compute\/7Swallow32MutableRepresentationConvertibleP","title":"Swallow.MutableRepresentationConvertible"},"doc://com.swallow.documentation.Compute/documentation/Compute/Strideable":{"kind":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Strideable","kind":"identifier"}],"url":"\/documentation\/compute\/strideable","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"constraints":[{"type":"codeVoice","code":"Pointee"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Strideable","navigatorTitle":[{"text":"Strideable","kind":"identifier"}],"abstract":[{"type":"text","text":"A type representing continuous, one-dimensional values that can be offset"},{"type":"text","text":" "},{"type":"text","text":"and measured."}],"title":"Strideable","role":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/_Pointer-Implementations":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/_Pointer-Implementations","title":"_Pointer Implementations","type":"topic","abstract":[],"kind":"article","role":"collectionGroup","url":"\/documentation\/compute\/unsafepointer\/_pointer-implementations"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer/withMemoryRebound(to:capacity:_:)":{"role":"symbol","type":"topic","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer\/withMemoryRebound(to:capacity:_:)","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"withMemoryRebound"},{"text":"<","kind":"text"},{"text":"T","kind":"genericParameter"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"E"},{"kind":"text","text":", "},{"text":"Result","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"to","kind":"externalParam"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"T"},{"text":".Type, ","kind":"text"},{"text":"capacity","kind":"externalParam"},{"text":": ","kind":"text"},{"preciseIdentifier":"s:Si","text":"Int","kind":"typeIdentifier"},{"kind":"text","text":", ("},{"text":"UnsafePointer","kind":"typeIdentifier","preciseIdentifier":"s:SP"},{"text":"<","kind":"text"},{"text":"T","kind":"typeIdentifier"},{"text":">) ","kind":"text"},{"text":"throws","kind":"keyword"},{"kind":"text","text":"("},{"text":"E","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"Result"},{"text":") ","kind":"text"},{"kind":"keyword","text":"throws"},{"text":"(","kind":"text"},{"text":"E","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Result","kind":"typeIdentifier"}],"title":"withMemoryRebound(to:capacity:_:)","url":"\/documentation\/compute\/unsafepointer\/withmemoryrebound(to:capacity:_:)","abstract":[{"type":"text","text":"Executes the given closure while temporarily binding memory to"},{"text":" ","type":"text"},{"text":"the specified number of instances of type ","type":"text"},{"code":"T","type":"codeVoice"},{"text":".","type":"text"}]}}}