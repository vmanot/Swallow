{"relationshipsSections":[{"title":"Inherits From","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable"],"kind":"relationships","type":"inheritsFrom"},{"title":"Inherited By","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryFloatingPoint","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryInteger","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DurationProtocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FixedWidthInteger","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPoint","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/InstantProtocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SignedInteger","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Strideable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/StringProtocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsignedInteger"],"type":"inheritedBy","kind":"relationships"},{"title":"Conforming Types","kind":"relationships","type":"conformingTypes","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyIndex","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AutoreleasingUnsafeMutablePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Character","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ClosedRange\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DiscontiguousSlice\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Double","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Duration","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FlattenSequence\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float16","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int128","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int16","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int32","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int64","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int8","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/LazyPrefixWhileSequence\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Never","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ObjectIdentifier","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/OpaquePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReversedCollection\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Set\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String\/Index","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Substring","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt128","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt16","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt32","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt64","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt8","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/CanonicalCombiningClass","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/Scalar","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutablePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutableRawPointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeRawPointer"]}],"abstract":[{"type":"text","text":"A type that can be compared using the relational operators "},{"code":"<","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"<="},{"type":"text","text":", "},{"type":"codeVoice","code":">="},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"and ","type":"text"},{"type":"codeVoice","code":">"},{"type":"text","text":"."}],"sections":[],"topicSections":[{"title":"Operators","generated":true,"anchor":"Operators","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/...(_:)-1quco","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/...(_:)-6mvrh","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/...(_:_:)","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/.._(_:)","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/.._(_:_:)","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_(_:_:)-8j02g","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_(_:_:)-9jp4d","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_=(_:_:)-4hu01","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_=(_:_:)-buc5"]}],"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"paths":["\/documentation\/compute\/comparable"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable"},"hierarchy":{"paths":[["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute"]]},"kind":"symbol","metadata":{"externalID":"s:SL","role":"symbol","roleHeading":"Protocol","modules":[{"name":"Compute"}],"symbolKind":"protocol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Comparable","kind":"identifier"}],"navigatorTitle":[{"text":"Comparable","kind":"identifier"}],"title":"Comparable"},"primaryContentSections":[{"kind":"declarations","declarations":[{"platforms":["macOS"],"languages":["swift"],"tokens":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"text":"Comparable","kind":"identifier"},{"text":" : ","kind":"text"},{"preciseIdentifier":"s:SQ","text":"Equatable","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable","kind":"typeIdentifier"}]}]},{"content":[{"level":2,"anchor":"overview","type":"heading","text":"Overview"},{"inlineContent":[{"type":"text","text":"The "},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" protocol is used for types that have an inherent order,"},{"type":"text","text":" "},{"type":"text","text":"such as numbers and strings. Many types in the standard library already"},{"text":" ","type":"text"},{"text":"conform to the ","type":"text"},{"code":"Comparable","type":"codeVoice"},{"text":" protocol. Add ","type":"text"},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" conformance to your"},{"type":"text","text":" "},{"type":"text","text":"own custom types when you want to be able to compare instances using"},{"type":"text","text":" "},{"type":"text","text":"relational operators or use standard library methods that are designed for"},{"text":" ","type":"text"},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" types."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The most familiar use of relational operators is to compare numbers, as in"},{"text":" ","type":"text"},{"text":"the following example:","type":"text"}],"type":"paragraph"},{"syntax":null,"code":["let currentTemp = 73","","if currentTemp >= 90 {","    print(\"It's a scorcher!\")","} else if currentTemp < 65 {","    print(\"Might need a sweater today.\")","} else {","    print(\"Seems like picnic weather!\")","}","\/\/ Prints \"Seems like picnic weather!\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"You can use special versions of some sequence and collection operations","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when working with a "},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" type. For example, if your array’s"},{"type":"text","text":" "},{"type":"text","text":"elements conform to "},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":", you can call the "},{"type":"codeVoice","code":"sort()"},{"type":"text","text":" method without"},{"text":" ","type":"text"},{"type":"text","text":"using arguments to sort the elements of your array in ascending order."}]},{"code":["var measurements = [1.1, 1.5, 2.9, 1.2, 1.5, 1.3, 1.2]","measurements.sort()","print(measurements)","\/\/ Prints \"[1.1, 1.2, 1.2, 1.3, 1.5, 1.5, 2.9]\""],"type":"codeListing","syntax":null},{"level":1,"type":"heading","text":"Conforming to the Comparable Protocol","anchor":"Conforming-to-the-Comparable-Protocol"},{"inlineContent":[{"text":"Types with Comparable conformance implement the less-than operator (","type":"text"},{"code":"<","type":"codeVoice"},{"text":")","type":"text"},{"text":" ","type":"text"},{"text":"and the equal-to operator (","type":"text"},{"code":"==","type":"codeVoice"},{"text":"). These two operations impose a strict","type":"text"},{"type":"text","text":" "},{"type":"text","text":"total order on the values of a type, in which exactly one of the following"},{"type":"text","text":" "},{"text":"must be true for any two values ","type":"text"},{"type":"codeVoice","code":"a"},{"text":" and ","type":"text"},{"code":"b","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"a == b"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"a < b"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"code":"b < a","type":"codeVoice"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In addition, the following conditions must hold:"}]},{"items":[{"content":[{"inlineContent":[{"code":"a < a","type":"codeVoice"},{"text":" is always ","type":"text"},{"code":"false","type":"codeVoice"},{"type":"text","text":" (Irreflexivity)"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"a < b","type":"codeVoice"},{"type":"text","text":" implies "},{"type":"codeVoice","code":"!(b < a)"},{"text":" (Asymmetry)","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"a < b"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"b < c"},{"text":" implies ","type":"text"},{"code":"a < c","type":"codeVoice"},{"text":" (Transitivity)","type":"text"}]}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"To add ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"text":" conformance to your custom types, define the ","type":"text"},{"code":"<","type":"codeVoice"},{"type":"text","text":" and"},{"text":" ","type":"text"},{"type":"codeVoice","code":"=="},{"text":" operators as static methods of your types. The ","type":"text"},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator is a"},{"text":" ","type":"text"},{"text":"requirement of the ","type":"text"},{"type":"codeVoice","code":"Equatable"},{"type":"text","text":" protocol, which "},{"type":"codeVoice","code":"Comparable"},{"text":" extends—see","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that protocol’s documentation for more information about equality in"},{"type":"text","text":" "},{"type":"text","text":"Swift. Because default implementations of the remainder of the relational"},{"type":"text","text":" "},{"text":"operators are provided by the standard library, you’ll be able to use","type":"text"},{"type":"text","text":" "},{"code":"!=","type":"codeVoice"},{"type":"text","text":", "},{"code":">","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"<="},{"text":", and ","type":"text"},{"code":">=","type":"codeVoice"},{"type":"text","text":" with instances of your type without any further"},{"text":" ","type":"text"},{"type":"text","text":"code."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As an example, here’s an implementation of a "},{"code":"Date","type":"codeVoice"},{"type":"text","text":" structure that stores"},{"type":"text","text":" "},{"text":"the year, month, and day of a date:","type":"text"}]},{"type":"codeListing","syntax":null,"code":["struct Date {","    let year: Int","    let month: Int","    let day: Int","}"]},{"type":"paragraph","inlineContent":[{"text":"To add ","type":"text"},{"code":"Comparable","type":"codeVoice"},{"type":"text","text":" conformance to "},{"type":"codeVoice","code":"Date"},{"type":"text","text":", first declare conformance to"},{"text":" ","type":"text"},{"type":"codeVoice","code":"Comparable"},{"type":"text","text":" and implement the "},{"code":"<","type":"codeVoice"},{"type":"text","text":" operator function."}]},{"syntax":null,"code":["extension Date: Comparable {","    static func < (lhs: Date, rhs: Date) -> Bool {","        if lhs.year != rhs.year {","            return lhs.year < rhs.year","        } else if lhs.month != rhs.month {","            return lhs.month < rhs.month","        } else {","            return lhs.day < rhs.day","        }","    }"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"This function uses the least specific nonmatching property of the date to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"determine the result of the comparison. For example, if the two "},{"code":"year","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"properties are equal but the two "},{"type":"codeVoice","code":"month"},{"text":" properties are not, the date with","type":"text"},{"text":" ","type":"text"},{"text":"the lesser value for ","type":"text"},{"type":"codeVoice","code":"month"},{"text":" is the lesser of the two dates.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Next, implement the "},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator function, the requirement inherited from"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"type":"text","text":" protocol."}],"type":"paragraph"},{"code":["    static func == (lhs: Date, rhs: Date) -> Bool {","        return lhs.year == rhs.year && lhs.month == rhs.month","            && lhs.day == rhs.day","    }","}"],"type":"codeListing","syntax":null},{"inlineContent":[{"type":"text","text":"Two "},{"type":"codeVoice","code":"Date"},{"text":" instances are equal if each of their corresponding properties is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"equal."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that "},{"type":"codeVoice","code":"Date"},{"type":"text","text":" conforms to "},{"code":"Comparable","type":"codeVoice"},{"text":", you can compare instances of the","type":"text"},{"type":"text","text":" "},{"text":"type with any of the relational operators. The following example compares","type":"text"},{"type":"text","text":" "},{"text":"the date of the first moon landing with the release of David Bowie’s song","type":"text"},{"type":"text","text":" "},{"type":"text","text":"“Space Oddity”:"}]},{"code":["let spaceOddity = Date(year: 1969, month: 7, day: 11)   \/\/ July 11, 1969","let moonLanding = Date(year: 1969, month: 7, day: 20)   \/\/ July 20, 1969","if moonLanding > spaceOddity {","    print(\"Major Tom stepped through the door first.\")","} else {","    print(\"David Bowie was following in Neil Armstrong's footsteps.\")","}","\/\/ Prints \"Major Tom stepped through the door first.\""],"syntax":null,"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the "},{"type":"codeVoice","code":">"},{"type":"text","text":" operator provided by the standard library is used in this"},{"text":" ","type":"text"},{"type":"text","text":"example, not the "},{"type":"codeVoice","code":"<"},{"text":" operator implemented above.","type":"text"}]},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"A conforming type may contain a subset of values which are treated"},{"type":"text","text":" "},{"type":"text","text":"as exceptional—that is, values that are outside the domain of"},{"text":" ","type":"text"},{"type":"text","text":"meaningful arguments for the purposes of the "},{"type":"codeVoice","code":"Comparable"},{"text":" protocol. For","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"example, the special “not a number” value for floating-point types"},{"type":"text","text":" "},{"text":"(","type":"text"},{"type":"codeVoice","code":"FloatingPoint.nan"},{"text":") compares as neither less than, greater than, nor","type":"text"},{"type":"text","text":" "},{"type":"text","text":"equal to any normal floating-point value. Exceptional values need not"},{"text":" ","type":"text"},{"text":"take part in the strict total order.","type":"text"}]}]}],"kind":"content"}],"references":{"doc://com.swallow.documentation.Compute/documentation/Compute/Int":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int","abstract":[{"type":"text","text":"A signed integer value type."}],"type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Int","kind":"identifier"}],"navigatorTitle":[{"text":"Int","kind":"identifier"}],"title":"Int","url":"\/documentation\/compute\/int","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt":{"kind":"symbol","navigatorTitle":[{"text":"UInt","kind":"identifier"}],"type":"topic","title":"UInt","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt","abstract":[{"text":"An unsigned integer value type.","type":"text"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"UInt","kind":"identifier"}],"url":"\/documentation\/compute\/uint"},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/_=(_:_:)-buc5":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_=(_:_:)-buc5","kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"<="},{"text":" ","kind":"text"},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"text":"Bool","preciseIdentifier":"s:Sb","kind":"typeIdentifier"}],"defaultImplementations":5,"abstract":[{"type":"text","text":"Returns a Boolean value indicating whether the value of the first"},{"text":" ","type":"text"},{"type":"text","text":"argument is less than or equal to that of the second argument."}],"role":"symbol","required":true,"title":"<=(_:_:)","url":"\/documentation\/compute\/comparable\/_=(_:_:)-buc5"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int32":{"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Int32","kind":"identifier"}],"abstract":[{"text":"A 32-bit signed integer value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"type."}],"kind":"symbol","navigatorTitle":[{"text":"Int32","kind":"identifier"}],"type":"topic","url":"\/documentation\/compute\/int32","title":"Int32","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int32"},"doc://com.swallow.documentation.Compute/documentation/Compute/BinaryFloatingPoint":{"navigatorTitle":[{"text":"BinaryFloatingPoint","kind":"identifier"}],"type":"topic","title":"BinaryFloatingPoint","abstract":[{"text":"A radix-2 (binary) floating-point type.","type":"text"}],"url":"\/documentation\/compute\/binaryfloatingpoint","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"BinaryFloatingPoint","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryFloatingPoint","kind":"symbol","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/AutoreleasingUnsafeMutablePointer":{"type":"topic","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"AutoreleasingUnsafeMutablePointer"}],"url":"\/documentation\/compute\/autoreleasingunsafemutablepointer","kind":"symbol","role":"symbol","abstract":[{"type":"text","text":"A mutable pointer addressing an Objective-C reference that doesn’t own its"},{"text":" ","type":"text"},{"type":"text","text":"target."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AutoreleasingUnsafeMutablePointer","navigatorTitle":[{"text":"AutoreleasingUnsafeMutablePointer","kind":"identifier"}],"title":"AutoreleasingUnsafeMutablePointer"},"doc://com.swallow.documentation.Compute/documentation/Compute/Never":{"title":"Never","navigatorTitle":[{"kind":"identifier","text":"Never"}],"abstract":[{"type":"text","text":"A type that has no values and can’t be constructed."}],"kind":"symbol","fragments":[{"kind":"keyword","text":"enum"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Never"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Never","role":"symbol","type":"topic","url":"\/documentation\/compute\/never"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt128":{"url":"\/documentation\/compute\/uint128","type":"topic","kind":"symbol","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt128","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"UInt128"}],"title":"UInt128","abstract":[{"text":"A 128-bit unsigned integer type.","type":"text"}],"navigatorTitle":[{"text":"UInt128","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ObjectIdentifier":{"title":"ObjectIdentifier","navigatorTitle":[{"text":"ObjectIdentifier","kind":"identifier"}],"type":"topic","url":"\/documentation\/compute\/objectidentifier","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"ObjectIdentifier","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ObjectIdentifier","abstract":[{"type":"text","text":"A unique identifier for a class instance or metatype."}],"role":"symbol","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafeMutablePointer":{"title":"UnsafeMutablePointer","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutablePointer","type":"topic","url":"\/documentation\/compute\/unsafemutablepointer","kind":"symbol","abstract":[{"text":"A pointer for accessing and manipulating data of a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"specific type."}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"UnsafeMutablePointer"}],"navigatorTitle":[{"text":"UnsafeMutablePointer","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Pointee","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Escapable","type":"codeVoice"},{"type":"text","text":"."}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/.._(_:_:)":{"role":"symbol","title":"..<(_:_:)","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"..<"},{"kind":"text","text":" "},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Range","preciseIdentifier":"s:Sn","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"text":">","kind":"text"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/.._(_:_:)","url":"\/documentation\/compute\/comparable\/'.._(_:_:)","type":"topic","kind":"symbol","abstract":[{"type":"text","text":"Returns a half-open range that contains its lower bound but not its upper"},{"type":"text","text":" "},{"text":"bound.","type":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt64":{"navigatorTitle":[{"text":"UInt64","kind":"identifier"}],"kind":"symbol","role":"symbol","type":"topic","title":"UInt64","abstract":[{"text":"A 64-bit unsigned integer value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"type."}],"url":"\/documentation\/compute\/uint64","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"UInt64","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt64"},"doc://com.swallow.documentation.Compute/documentation/Compute/Unicode/CanonicalCombiningClass":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/CanonicalCombiningClass","type":"topic","title":"Unicode.CanonicalCombiningClass","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"CanonicalCombiningClass","kind":"identifier"}],"navigatorTitle":[{"text":"CanonicalCombiningClass","kind":"identifier"}],"url":"\/documentation\/compute\/unicode\/canonicalcombiningclass","role":"symbol","kind":"symbol","abstract":[{"text":"The classification of a scalar used in the Canonical Ordering Algorithm","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"defined by the Unicode Standard."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable":{"url":"\/documentation\/compute\/comparable","type":"topic","kind":"symbol","role":"symbol","abstract":[{"text":"A type that can be compared using the relational operators ","type":"text"},{"code":"<","type":"codeVoice"},{"text":", ","type":"text"},{"code":"<=","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":">="},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"codeVoice","code":">"},{"text":".","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Comparable"}],"title":"Comparable","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"text":"Comparable","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafePointer":{"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafePointer","title":"UnsafePointer","url":"\/documentation\/compute\/unsafepointer","kind":"symbol","abstract":[{"type":"text","text":"A pointer for accessing data of a specific type."}],"role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"UnsafePointer","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"UnsafePointer"}],"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Pointee"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Escapable"},{"type":"text","text":"."}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/FlattenSequence/Index":{"url":"\/documentation\/compute\/flattensequence\/index","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"Index"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Base"},{"type":"text","text":" conforms to "},{"code":"Collection","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"Base.Element","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Collection"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"type":"topic","title":"FlattenSequence.Index","kind":"symbol","abstract":[{"type":"text","text":"A position in a FlattenCollection"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FlattenSequence\/Index"},"doc://com.swallow.documentation.Compute/documentation/Compute/Double":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Double","abstract":[{"text":"A double-precision, floating-point value type.","type":"text"}],"title":"Double","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"Double","kind":"identifier"}],"role":"symbol","navigatorTitle":[{"text":"Double","kind":"identifier"}],"kind":"symbol","type":"topic","url":"\/documentation\/compute\/double"},"doc://com.swallow.documentation.Compute/documentation/Compute/StringProtocol":{"url":"\/documentation\/compute\/stringprotocol","role":"symbol","abstract":[{"type":"text","text":"A type that can represent a string as a collection of characters."}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/StringProtocol","title":"StringProtocol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"StringProtocol","kind":"identifier"}],"navigatorTitle":[{"text":"StringProtocol","kind":"identifier"}],"kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Float":{"type":"topic","abstract":[{"text":"A single-precision, floating-point value type.","type":"text"}],"url":"\/documentation\/compute\/float","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Float"}],"navigatorTitle":[{"text":"Float","kind":"identifier"}],"title":"Float"},"doc://com.swallow.documentation.Compute/documentation/Compute/String/Index":{"abstract":[{"type":"text","text":"A position of a character or code unit in a string."}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}],"url":"\/documentation\/compute\/string\/index","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String\/Index","kind":"symbol","title":"String.Index","role":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Index"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/DurationProtocol":{"url":"\/documentation\/compute\/durationprotocol","fragments":[{"kind":"keyword","text":"protocol"},{"text":" ","kind":"text"},{"kind":"identifier","text":"DurationProtocol"}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DurationProtocol","title":"DurationProtocol","role":"symbol","abstract":[{"text":"A type that defines a duration for a given ","type":"text"},{"type":"codeVoice","code":"InstantProtocol"},{"text":" type.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"DurationProtocol"}],"kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/_=(_:_:)-4hu01":{"role":"symbol","kind":"symbol","required":true,"title":">=(_:_:)","url":"\/documentation\/compute\/comparable\/_=(_:_:)-4hu01","fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":">="},{"kind":"text","text":" "},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":", "},{"kind":"typeIdentifier","text":"Self"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"}],"abstract":[{"text":"Returns a Boolean value indicating whether the value of the first","type":"text"},{"type":"text","text":" "},{"text":"argument is greater than or equal to that of the second argument.","type":"text"}],"type":"topic","defaultImplementations":5,"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_=(_:_:)-4hu01"},"doc://com.swallow.documentation.Compute/documentation/Compute/Character":{"title":"Character","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Character","abstract":[{"type":"text","text":"A single extended grapheme cluster that approximates a user-perceived"},{"type":"text","text":" "},{"text":"character.","type":"text"}],"type":"topic","role":"symbol","url":"\/documentation\/compute\/character","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Character"}],"navigatorTitle":[{"kind":"identifier","text":"Character"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Duration":{"abstract":[{"type":"text","text":"A representation of high precision time."}],"type":"topic","role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Duration","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Duration"}],"url":"\/documentation\/compute\/duration","navigatorTitle":[{"kind":"identifier","text":"Duration"}],"title":"Duration","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Strideable":{"type":"topic","kind":"symbol","role":"symbol","url":"\/documentation\/compute\/strideable","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Strideable","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Strideable"}],"navigatorTitle":[{"text":"Strideable","kind":"identifier"}],"abstract":[{"type":"text","text":"A type representing continuous, one-dimensional values that can be offset"},{"type":"text","text":" "},{"type":"text","text":"and measured."}],"title":"Strideable"},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafeRawPointer":{"role":"symbol","abstract":[{"text":"A raw pointer for accessing untyped data.","type":"text"}],"title":"UnsafeRawPointer","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnsafeRawPointer"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeRawPointer","kind":"symbol","navigatorTitle":[{"text":"UnsafeRawPointer","kind":"identifier"}],"url":"\/documentation\/compute\/unsaferawpointer","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/Substring":{"navigatorTitle":[{"kind":"identifier","text":"Substring"}],"url":"\/documentation\/compute\/substring","title":"Substring","abstract":[{"text":"A slice of a string.","type":"text"}],"type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Substring","kind":"identifier"}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Substring","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/...(_:)-1quco":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/...(_:)-1quco","role":"symbol","kind":"symbol","url":"\/documentation\/compute\/comparable\/'...(_:)-1quco","type":"topic","abstract":[{"type":"text","text":"Returns a partial range up to, and including, its upper bound."}],"fragments":[{"text":"static","kind":"keyword"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"...","kind":"identifier"},{"text":" ","kind":"text"},{"kind":"text","text":"("},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"preciseIdentifier":"s:s19PartialRangeThroughV","text":"PartialRangeThrough","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":">"}],"title":"...(_:)"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt8":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"UInt8","kind":"identifier"}],"navigatorTitle":[{"text":"UInt8","kind":"identifier"}],"title":"UInt8","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt8","url":"\/documentation\/compute\/uint8","kind":"symbol","role":"symbol","type":"topic","abstract":[{"type":"text","text":"An 8-bit unsigned integer value"},{"text":" ","type":"text"},{"text":"type.","type":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Float16":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Float16","navigatorTitle":[{"kind":"identifier","text":"Float16"}],"role":"symbol","title":"Float16","url":"\/documentation\/compute\/float16","type":"topic","abstract":[{"type":"text","text":"A half-precision (16b), floating-point value type."}],"kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Float16"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Equatable":{"abstract":[{"text":"A type that can be compared for value equality.","type":"text"}],"type":"topic","title":"Equatable","kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Equatable"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Equatable","role":"symbol","url":"\/documentation\/compute\/equatable","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Equatable","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ClosedRange/Index":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ClosedRange\/Index","type":"topic","abstract":[{"type":"text","text":"A type that represents a position in the collection."}],"fragments":[{"text":"enum","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Index"}],"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Bound","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Strideable","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Bound.Stride","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"code":"SignedInteger","type":"codeVoice"},{"text":".","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"kind":"symbol","title":"ClosedRange.Index","navigatorTitle":[{"kind":"identifier","text":"Index"}],"url":"\/documentation\/compute\/closedrange\/index","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute","url":"\/documentation\/compute","role":"collection","kind":"symbol","abstract":[],"type":"topic","title":"Compute"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt16":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"UInt16","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"UInt16"}],"title":"UInt16","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt16","url":"\/documentation\/compute\/uint16","kind":"symbol","role":"symbol","abstract":[{"text":"A 16-bit unsigned integer value","type":"text"},{"text":" ","type":"text"},{"text":"type.","type":"text"}],"type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/OpaquePointer":{"role":"symbol","navigatorTitle":[{"text":"OpaquePointer","kind":"identifier"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"OpaquePointer","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/OpaquePointer","type":"topic","title":"OpaquePointer","kind":"symbol","abstract":[{"type":"text","text":"A wrapper around an opaque C pointer."}],"url":"\/documentation\/compute\/opaquepointer"},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/_(_:_:)-9jp4d":{"role":"symbol","required":true,"abstract":[{"text":"Returns a Boolean value indicating whether the value of the first","type":"text"},{"text":" ","type":"text"},{"text":"argument is less than that of the second argument.","type":"text"}],"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"<"},{"kind":"text","text":" "},{"kind":"text","text":"("},{"text":"Self","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","preciseIdentifier":"s:Sb","text":"Bool"}],"url":"\/documentation\/compute\/comparable\/_(_:_:)-9jp4d","defaultImplementations":4,"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_(_:_:)-9jp4d","type":"topic","title":"<(_:_:)","kind":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int64":{"url":"\/documentation\/compute\/int64","title":"Int64","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int64","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Int64"}],"abstract":[{"type":"text","text":"A 64-bit signed integer value"},{"text":" ","type":"text"},{"text":"type.","type":"text"}],"navigatorTitle":[{"text":"Int64","kind":"identifier"}],"type":"topic","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/...(_:)-6mvrh":{"fragments":[{"kind":"keyword","text":"static"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"..."},{"kind":"text","text":" "},{"text":"(","kind":"text"},{"kind":"typeIdentifier","text":"Self"},{"text":") -> ","kind":"text"},{"text":"PartialRangeFrom","preciseIdentifier":"s:s16PartialRangeFromV","kind":"typeIdentifier"},{"kind":"text","text":"<"},{"kind":"typeIdentifier","text":"Self"},{"kind":"text","text":">"}],"kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/...(_:)-6mvrh","type":"topic","abstract":[{"type":"text","text":"Returns a partial range extending upward from a lower bound."}],"role":"symbol","title":"...(_:)","url":"\/documentation\/compute\/comparable\/'...(_:)-6mvrh"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int128":{"url":"\/documentation\/compute\/int128","abstract":[{"type":"text","text":"A 128-bit signed integer type."}],"title":"Int128","role":"symbol","navigatorTitle":[{"text":"Int128","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int128","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Int128"}],"kind":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/BinaryInteger":{"fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"BinaryInteger"}],"navigatorTitle":[{"kind":"identifier","text":"BinaryInteger"}],"url":"\/documentation\/compute\/binaryinteger","type":"topic","abstract":[{"type":"text","text":"An integer type with a binary representation."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/BinaryInteger","title":"BinaryInteger","kind":"symbol","role":"symbol"},"doc://com.swallow.documentation.Compute/documentation/Compute/FixedWidthInteger":{"title":"FixedWidthInteger","kind":"symbol","navigatorTitle":[{"text":"FixedWidthInteger","kind":"identifier"}],"role":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FixedWidthInteger","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"FixedWidthInteger","kind":"identifier"}],"abstract":[{"text":"An integer type that uses a fixed size for every instance.","type":"text"}],"type":"topic","url":"\/documentation\/compute\/fixedwidthinteger"},"doc://com.swallow.documentation.Compute/documentation/Compute/UInt32":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UInt32","title":"UInt32","abstract":[{"type":"text","text":"A 32-bit unsigned integer value"},{"type":"text","text":" "},{"text":"type.","type":"text"}],"kind":"symbol","navigatorTitle":[{"text":"UInt32","kind":"identifier"}],"url":"\/documentation\/compute\/uint32","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"UInt32","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/...(_:_:)":{"role":"symbol","title":"...(_:_:)","fragments":[{"text":"static","kind":"keyword"},{"kind":"text","text":" "},{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"...","kind":"identifier"},{"kind":"text","text":" "},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"text":"ClosedRange","kind":"typeIdentifier","preciseIdentifier":"s:SN"},{"text":"<","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":">","kind":"text"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/...(_:_:)","url":"\/documentation\/compute\/comparable\/'...(_:_:)","type":"topic","kind":"symbol","abstract":[{"type":"text","text":"Returns a closed range that contains both of its bounds."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsignedInteger":{"url":"\/documentation\/compute\/unsignedinteger","abstract":[{"type":"text","text":"An integer type that can represent only nonnegative values."}],"kind":"symbol","navigatorTitle":[{"text":"UnsignedInteger","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsignedInteger","title":"UnsignedInteger","role":"symbol","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"UnsignedInteger"}],"type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/LazyPrefixWhileSequence/Index":{"url":"\/documentation\/compute\/lazyprefixwhilesequence\/index","kind":"symbol","abstract":[{"type":"text","text":"A position in a "},{"type":"codeVoice","code":"LazyPrefixWhileCollection"},{"type":"text","text":" or"},{"text":" ","type":"text"},{"type":"codeVoice","code":"LazyPrefixWhileBidirectionalCollection"},{"type":"text","text":" instance."}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/LazyPrefixWhileSequence\/Index","title":"LazyPrefixWhileSequence.Index","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"Index"}],"conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Base","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Collection"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/FloatingPoint":{"url":"\/documentation\/compute\/floatingpoint","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/FloatingPoint","title":"FloatingPoint","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"text":"FloatingPoint","kind":"identifier"}],"navigatorTitle":[{"text":"FloatingPoint","kind":"identifier"}],"abstract":[{"text":"A floating-point numeric type.","type":"text"}],"kind":"symbol","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/Int8":{"kind":"symbol","navigatorTitle":[{"kind":"identifier","text":"Int8"}],"url":"\/documentation\/compute\/int8","title":"Int8","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Int8"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int8","abstract":[{"text":"An 8-bit signed integer value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"type."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/InstantProtocol":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/InstantProtocol","abstract":[],"url":"\/documentation\/compute\/instantprotocol","kind":"symbol","title":"InstantProtocol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"InstantProtocol","kind":"identifier"}],"type":"topic","role":"symbol","navigatorTitle":[{"text":"InstantProtocol","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/CollectionDifference/Index":{"type":"topic","role":"symbol","navigatorTitle":[{"kind":"identifier","text":"Index"}],"kind":"symbol","title":"CollectionDifference.Index","abstract":[{"type":"text","text":"The position of a collection difference."}],"url":"\/documentation\/compute\/collectiondifference\/index","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"ChangeElement","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Copyable"},{"type":"text","text":" and "},{"code":"Escapable","type":"codeVoice"},{"type":"text","text":"."}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/CollectionDifference\/Index"},"doc://com.swallow.documentation.Compute/documentation/Compute/DiscontiguousSlice/Index":{"title":"DiscontiguousSlice.Index","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Index"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/DiscontiguousSlice\/Index","navigatorTitle":[{"text":"Index","kind":"identifier"}],"url":"\/documentation\/compute\/discontiguousslice\/index","abstract":[{"type":"text","text":"A position in a "},{"type":"codeVoice","code":"DiscontiguousSlice"},{"type":"text","text":"."}],"type":"topic","kind":"symbol","role":"symbol","conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Base","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Collection"},{"type":"text","text":"."}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/.._(_:)":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/.._(_:)","role":"symbol","kind":"symbol","url":"\/documentation\/compute\/comparable\/'.._(_:)","type":"topic","abstract":[{"type":"text","text":"Returns a partial range up to, but not including, its upper bound."}],"fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"..<"},{"text":" ","kind":"text"},{"text":"(","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:s16PartialRangeUpToV","kind":"typeIdentifier","text":"PartialRangeUpTo"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Self"},{"text":">","kind":"text"}],"title":"..<(_:)"},"doc://com.swallow.documentation.Compute/documentation/Compute/String":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"String"}],"title":"String","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"String","kind":"identifier"}],"abstract":[{"type":"text","text":"A Unicode string value that is a collection of characters."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/String","kind":"symbol","role":"symbol","url":"\/documentation\/compute\/string"},"doc://com.swallow.documentation.Compute/documentation/Compute/Comparable/_(_:_:)-8j02g":{"url":"\/documentation\/compute\/comparable\/_(_:_:)-8j02g","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Comparable\/_(_:_:)-8j02g","defaultImplementations":5,"type":"topic","abstract":[{"text":"Returns a Boolean value indicating whether the value of the first","type":"text"},{"type":"text","text":" "},{"text":"argument is greater than that of the second argument.","type":"text"}],"role":"symbol","fragments":[{"text":"static","kind":"keyword"},{"text":" ","kind":"text"},{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":">","kind":"identifier"},{"text":" ","kind":"text"},{"text":"(","kind":"text"},{"kind":"typeIdentifier","text":"Self"},{"text":", ","kind":"text"},{"text":"Self","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"Bool","preciseIdentifier":"s:Sb"}],"kind":"symbol","title":">(_:_:)","required":true},"doc://com.swallow.documentation.Compute/documentation/Compute/UnsafeMutableRawPointer":{"kind":"symbol","type":"topic","abstract":[{"text":"A raw pointer for accessing and manipulating untyped data.","type":"text"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/UnsafeMutableRawPointer","url":"\/documentation\/compute\/unsafemutablerawpointer","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"UnsafeMutableRawPointer"}],"title":"UnsafeMutableRawPointer","navigatorTitle":[{"kind":"identifier","text":"UnsafeMutableRawPointer"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/ReversedCollection/Index":{"title":"ReversedCollection.Index","type":"topic","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Index","kind":"identifier"}],"kind":"symbol","role":"symbol","navigatorTitle":[{"text":"Index","kind":"identifier"}],"conformance":{"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Base","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"BidirectionalCollection"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]},"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/ReversedCollection\/Index","url":"\/documentation\/compute\/reversedcollection\/index","abstract":[{"type":"text","text":"An index that traverses the same positions as an underlying index,"},{"type":"text","text":" "},{"text":"with inverted traversal direction.","type":"text"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Int16":{"title":"Int16","abstract":[{"text":"A 16-bit signed integer value","type":"text"},{"type":"text","text":" "},{"text":"type.","type":"text"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Int16","kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Int16"}],"type":"topic","url":"\/documentation\/compute\/int16","navigatorTitle":[{"kind":"identifier","text":"Int16"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/AnyIndex":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"AnyIndex","kind":"identifier"}],"url":"\/documentation\/compute\/anyindex","kind":"symbol","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/AnyIndex","role":"symbol","abstract":[{"text":"A wrapper over an underlying index that hides the specific underlying type.","type":"text"}],"navigatorTitle":[{"text":"AnyIndex","kind":"identifier"}],"type":"topic","title":"AnyIndex"},"doc://com.swallow.documentation.Compute/documentation/Compute/Set/Index":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Set\/Index","title":"Set.Index","abstract":[{"type":"text","text":"The position of an element in a set."}],"url":"\/documentation\/compute\/set\/index","navigatorTitle":[{"kind":"identifier","text":"Index"}],"type":"topic","conformance":{"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Element","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Hashable"},{"text":".","type":"text"}],"availabilityPrefix":[{"type":"text","text":"Available when"}]},"kind":"symbol","role":"symbol","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"text":"Index","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/Unicode/Scalar":{"title":"Unicode.Scalar","type":"topic","kind":"symbol","navigatorTitle":[{"text":"Scalar","kind":"identifier"}],"fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"text":"Scalar","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Unicode\/Scalar","abstract":[{"type":"text","text":"A Unicode scalar value."}],"role":"symbol","url":"\/documentation\/compute\/unicode\/scalar"},"doc://com.swallow.documentation.Compute/documentation/Compute/Dictionary/Index":{"type":"topic","navigatorTitle":[{"kind":"identifier","text":"Index"}],"conformance":{"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"code":"Key","type":"codeVoice"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":", "},{"code":"Value","type":"codeVoice"},{"type":"text","text":" conforms to "},{"code":"Copyable","type":"codeVoice"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Value"},{"type":"text","text":" conforms to "},{"code":"Escapable","type":"codeVoice"},{"type":"text","text":"."}]},"abstract":[{"type":"text","text":"The position of a key-value pair in a dictionary."}],"title":"Dictionary.Index","url":"\/documentation\/compute\/dictionary\/index","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Dictionary\/Index","role":"symbol","kind":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Index","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute/SignedInteger":{"abstract":[{"type":"text","text":"An integer type that can represent both positive and negative values."}],"kind":"symbol","url":"\/documentation\/compute\/signedinteger","navigatorTitle":[{"kind":"identifier","text":"SignedInteger"}],"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/SignedInteger","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"SignedInteger","kind":"identifier"}],"title":"SignedInteger"}}}