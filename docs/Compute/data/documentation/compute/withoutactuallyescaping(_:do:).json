{"abstract":[{"type":"text","text":"Allows a nonescaping closure to temporarily be used as if it were allowed"},{"text":" ","type":"text"},{"type":"text","text":"to escape."}],"kind":"symbol","sections":[],"metadata":{"modules":[{"name":"Compute"}],"symbolKind":"func","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"withoutActuallyEscaping","kind":"identifier"},{"text":"<","kind":"text"},{"text":"ClosureType","kind":"genericParameter"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"ResultType"},{"kind":"text","text":", "},{"kind":"genericParameter","text":"Failure"},{"text":">(","kind":"text"},{"text":"ClosureType","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"do"},{"text":": (","kind":"text"},{"text":"ClosureType","kind":"typeIdentifier"},{"text":") ","kind":"text"},{"kind":"keyword","text":"throws"},{"kind":"text","text":"("},{"text":"Failure","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"text":"ResultType","kind":"typeIdentifier"},{"kind":"text","text":") "},{"text":"throws","kind":"keyword"},{"kind":"text","text":"("},{"kind":"typeIdentifier","text":"Failure"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"ResultType"}],"role":"symbol","title":"withoutActuallyEscaping(_:do:)","externalID":"s:s23withoutActuallyEscaping_2doq_x_q_xq0_YKXEtq0_YKs5ErrorR0_r1_lF","roleHeading":"Function"},"primaryContentSections":[{"declarations":[{"languages":["swift"],"platforms":["macOS"],"tokens":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"withoutActuallyEscaping"},{"text":"<","kind":"text"},{"text":"ClosureType","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"ResultType","kind":"genericParameter"},{"text":", ","kind":"text"},{"text":"Failure","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"_","kind":"externalParam"},{"kind":"text","text":" "},{"kind":"internalParam","text":"closure"},{"text":": ","kind":"text"},{"kind":"typeIdentifier","text":"ClosureType"},{"text":", ","kind":"text"},{"kind":"externalParam","text":"do"},{"text":" ","kind":"text"},{"text":"body","kind":"internalParam"},{"kind":"text","text":": ("},{"kind":"typeIdentifier","text":"ClosureType"},{"text":") ","kind":"text"},{"kind":"keyword","text":"throws"},{"text":"(","kind":"text"},{"text":"Failure","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"ResultType","kind":"typeIdentifier"},{"kind":"text","text":") "},{"text":"throws","kind":"keyword"},{"text":"(","kind":"text"},{"kind":"typeIdentifier","text":"Failure"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"ResultType"},{"text":" ","kind":"text"},{"text":"where","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Failure","kind":"typeIdentifier"},{"text":" : ","kind":"text"},{"kind":"typeIdentifier","text":"Error","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Error","preciseIdentifier":"s:s5ErrorP"}]}],"kind":"declarations"},{"parameters":[{"name":"closure","content":[{"inlineContent":[{"type":"text","text":"A nonescaping closure value that is made escapable for the"},{"type":"text","text":" "},{"text":"duration of the execution of the ","type":"text"},{"type":"codeVoice","code":"body"},{"text":" closure. If ","type":"text"},{"code":"body","type":"codeVoice"},{"text":" has a","type":"text"},{"type":"text","text":" "},{"type":"text","text":"return value, that value is also used as the return value for the"},{"type":"text","text":" "},{"code":"withoutActuallyEscaping(_:do:)","type":"codeVoice"},{"type":"text","text":" function."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"A closure that is executed immediately with an escapable copy of","type":"text"},{"text":" ","type":"text"},{"code":"closure","type":"codeVoice"},{"text":" as its argument.","type":"text"}]}],"name":"body"}],"kind":"parameters"},{"kind":"content","content":[{"anchor":"return-value","text":"Return Value","level":2,"type":"heading"},{"inlineContent":[{"type":"text","text":"The return value, if any, of the "},{"code":"body","type":"codeVoice"},{"text":" closure.","type":"text"}],"type":"paragraph"}]},{"kind":"content","content":[{"anchor":"discussion","text":"Discussion","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can use this function to call an API that takes an escaping closure in"},{"text":" ","type":"text"},{"type":"text","text":"a way that doesn’t allow the closure to escape in practice. The examples"},{"text":" ","type":"text"},{"type":"text","text":"below demonstrate how to use "},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"type":"text","text":" in"},{"type":"text","text":" "},{"text":"conjunction with two common APIs that use escaping closures: lazy","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"collection views and asynchronous operations."}]},{"type":"paragraph","inlineContent":[{"text":"The following code declares an ","type":"text"},{"type":"codeVoice","code":"allValues(in:match:)"},{"text":" function that checks","type":"text"},{"type":"text","text":" "},{"type":"text","text":"whether all the elements in an array match a predicate. The function won’t"},{"type":"text","text":" "},{"text":"compile as written, because a lazy collection’s ","type":"text"},{"code":"filter(_:)","type":"codeVoice"},{"text":" method","type":"text"},{"text":" ","type":"text"},{"text":"requires an escaping closure. The lazy collection isn’t persisted, so the","type":"text"},{"type":"text","text":" "},{"code":"predicate","type":"codeVoice"},{"text":" closure won’t actually escape the body of the function;","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"nevertheless, it can’t be used in this way."}]},{"code":["func allValues(in array: [Int], match predicate: (Int) -> Bool) -> Bool {","    return array.lazy.filter { !predicate($0) }.isEmpty","}","\/\/ error: closure use of non-escaping parameter 'predicate'..."],"syntax":null,"type":"codeListing"},{"type":"paragraph","inlineContent":[{"code":"withoutActuallyEscaping(_:do:)","type":"codeVoice"},{"type":"text","text":" provides a temporarily escapable copy of"},{"type":"text","text":" "},{"code":"predicate","type":"codeVoice"},{"type":"text","text":" that "},{"type":"emphasis","inlineContent":[{"type":"text","text":"can"}]},{"type":"text","text":" be used in a call to the lazy view’s "},{"type":"codeVoice","code":"filter(_:)"},{"text":" ","type":"text"},{"type":"text","text":"method. The second version of "},{"code":"allValues(in:match:)","type":"codeVoice"},{"text":" compiles without","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"error, with the compiler guaranteeing that the "},{"code":"escapablePredicate","type":"codeVoice"},{"type":"text","text":" "},{"text":"closure doesn’t last beyond the call to ","type":"text"},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"text":".","type":"text"}]},{"code":["func allValues(in array: [Int], match predicate: (Int) -> Bool) -> Bool {","    return withoutActuallyEscaping(predicate) { escapablePredicate in","        array.lazy.filter { !escapablePredicate($0) }.isEmpty","    }","}"],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"Asynchronous calls are another type of API that typically escape their"},{"text":" ","type":"text"},{"type":"text","text":"closure arguments. The following code declares a"},{"text":" ","type":"text"},{"code":"perform(_:simultaneouslyWith:)","type":"codeVoice"},{"text":" function that uses a dispatch queue to","type":"text"},{"type":"text","text":" "},{"text":"execute two closures concurrently.","type":"text"}]},{"code":["func perform(_ f: () -> Void, simultaneouslyWith g: () -> Void) {","    let queue = DispatchQueue(label: \"perform\", attributes: .concurrent)","    queue.async(execute: f)","    queue.async(execute: g)","    queue.sync(flags: .barrier) {}","}","\/\/ error: passing non-escaping parameter 'f'...","\/\/ error: passing non-escaping parameter 'g'..."],"type":"codeListing","syntax":null},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"perform(_:simultaneouslyWith:)"},{"type":"text","text":" function ends with a call to the"},{"text":" ","type":"text"},{"type":"codeVoice","code":"sync(flags:execute:)"},{"type":"text","text":" method using the "},{"code":".barrier","type":"codeVoice"},{"type":"text","text":" flag, which forces the"},{"type":"text","text":" "},{"type":"text","text":"function to wait until both closures have completed running before"},{"type":"text","text":" "},{"type":"text","text":"returning. Even though the barrier guarantees that neither closure will"},{"text":" ","type":"text"},{"type":"text","text":"escape the function, the "},{"code":"async(execute:)","type":"codeVoice"},{"type":"text","text":" method still requires that the"},{"text":" ","type":"text"},{"text":"closures passed be marked as ","type":"text"},{"code":"@escaping","type":"codeVoice"},{"text":", so the first version of the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"function does not compile. To resolve these errors, you can use"},{"text":" ","type":"text"},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"type":"text","text":" to get copies of "},{"type":"codeVoice","code":"f"},{"type":"text","text":" and "},{"type":"codeVoice","code":"g"},{"text":" that can be","type":"text"},{"type":"text","text":" "},{"type":"text","text":"passed to "},{"code":"async(execute:)","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"codeListing","syntax":null,"code":["func perform(_ f: () -> Void, simultaneouslyWith g: () -> Void) {","    withoutActuallyEscaping(f) { escapableF in","        withoutActuallyEscaping(g) { escapableG in","            let queue = DispatchQueue(label: \"perform\", attributes: .concurrent)","            queue.async(execute: escapableF)","            queue.async(execute: escapableG)","            queue.sync(flags: .barrier) {}","        }","    }","}"]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The escapable copy of "},{"code":"closure","type":"codeVoice"},{"text":" passed to ","type":"text"},{"type":"codeVoice","code":"body"},{"type":"text","text":" is only valid"},{"text":" ","type":"text"},{"type":"text","text":"during the call to "},{"type":"codeVoice","code":"withoutActuallyEscaping(_:do:)"},{"type":"text","text":". It is undefined"},{"type":"text","text":" "},{"type":"text","text":"behavior for the escapable closure to be stored, referenced, or executed"},{"text":" ","type":"text"},{"type":"text","text":"after the function returns."}]}],"name":"Important","type":"aside","style":"important"}]}],"schemaVersion":{"patch":0,"major":0,"minor":3},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/compute\/withoutactuallyescaping(_:do:)"]}],"hierarchy":{"paths":[["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/withoutActuallyEscaping(_:do:)"},"references":{"doc://com.swallow.documentation.Compute/documentation/Compute/Error":{"url":"\/documentation\/compute\/error","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"Error"}],"navigatorTitle":[{"text":"Error","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Error","type":"topic","role":"symbol","abstract":[{"type":"text","text":"A type representing an error value that can be thrown."}],"kind":"symbol","title":"Error"},"doc://com.swallow.documentation.Compute/documentation/Compute":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute","url":"\/documentation\/compute","role":"collection","kind":"symbol","abstract":[],"type":"topic","title":"Compute"},"doc://com.swallow.documentation.Compute/documentation/Compute/withoutActuallyEscaping(_:do:)":{"type":"topic","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/withoutActuallyEscaping(_:do:)","role":"symbol","url":"\/documentation\/compute\/withoutactuallyescaping(_:do:)","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"withoutActuallyEscaping"},{"kind":"text","text":"<"},{"kind":"genericParameter","text":"ClosureType"},{"text":", ","kind":"text"},{"kind":"genericParameter","text":"ResultType"},{"text":", ","kind":"text"},{"text":"Failure","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"ClosureType","kind":"typeIdentifier"},{"kind":"text","text":", "},{"kind":"externalParam","text":"do"},{"text":": (","kind":"text"},{"text":"ClosureType","kind":"typeIdentifier"},{"kind":"text","text":") "},{"text":"throws","kind":"keyword"},{"text":"(","kind":"text"},{"kind":"typeIdentifier","text":"Failure"},{"kind":"text","text":") -> "},{"text":"ResultType","kind":"typeIdentifier"},{"kind":"text","text":") "},{"kind":"keyword","text":"throws"},{"text":"(","kind":"text"},{"kind":"typeIdentifier","text":"Failure"},{"text":") -> ","kind":"text"},{"kind":"typeIdentifier","text":"ResultType"}],"abstract":[{"text":"Allows a nonescaping closure to temporarily be used as if it were allowed","type":"text"},{"type":"text","text":" "},{"text":"to escape.","type":"text"}],"title":"withoutActuallyEscaping(_:do:)","kind":"symbol"}}}