{"relationshipsSections":[{"kind":"relationships","title":"Conforms To","identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Copyable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IteratorProtocol","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Sendable","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Sequence"],"type":"conformsTo"}],"primaryContentSections":[{"kind":"declarations","declarations":[{"tokens":[{"kind":"attribute","text":"@frozen"},{"text":" ","kind":"text"},{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"IndexingIterator"},{"text":"<","kind":"text"},{"text":"Elements","kind":"genericParameter"},{"text":"> ","kind":"text"},{"text":"where","kind":"keyword"},{"kind":"text","text":" "},{"kind":"typeIdentifier","text":"Elements"},{"text":" : ","kind":"text"},{"kind":"typeIdentifier","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Collection","preciseIdentifier":"s:Sl","text":"Collection"}],"languages":["swift"],"platforms":["macOS"]}]},{"kind":"content","content":[{"type":"heading","level":2,"anchor":"overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"IndexingIterator","type":"codeVoice"},{"type":"text","text":" type is the default iterator for any collection that"},{"text":" ","type":"text"},{"text":"doesn’t declare its own. It acts as an iterator by using a collection’s","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"indices to step over each value in the collection. Most collections in the"},{"type":"text","text":" "},{"text":"standard library use ","type":"text"},{"type":"codeVoice","code":"IndexingIterator"},{"text":" as their iterator.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"By default, any custom collection type you create will inherit a","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"makeIterator()"},{"type":"text","text":" method that returns an "},{"type":"codeVoice","code":"IndexingIterator"},{"type":"text","text":" instance,"},{"type":"text","text":" "},{"text":"making it unnecessary to declare your own. When creating a custom","type":"text"},{"text":" ","type":"text"},{"text":"collection type, add the minimal requirements of the ","type":"text"},{"code":"Collection","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"protocol: starting and ending indices and a subscript for accessing"},{"type":"text","text":" "},{"type":"text","text":"elements. With those elements defined, the inherited "},{"code":"makeIterator()","type":"codeVoice"},{"type":"text","text":" "},{"text":"method satisfies the requirements of the ","type":"text"},{"code":"Sequence","type":"codeVoice"},{"type":"text","text":" protocol."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a type that declares the minimal requirements for a"},{"text":" ","type":"text"},{"type":"text","text":"collection. The "},{"code":"CollectionOfTwo","type":"codeVoice"},{"type":"text","text":" structure is a fixed-size collection"},{"text":" ","type":"text"},{"type":"text","text":"that always holds two elements of a specific type."}]},{"syntax":null,"code":["struct CollectionOfTwo<Element>: Collection {","    let elements: (Element, Element)","","    init(_ first: Element, _ second: Element) {","        self.elements = (first, second)","    }","","    var startIndex: Int { return 0 }","    var endIndex: Int   { return 2 }","","    subscript(index: Int) -> Element {","        switch index {","        case 0: return elements.0","        case 1: return elements.1","        default: fatalError(\"Index out of bounds.\")","        }","    }","    ","    func index(after i: Int) -> Int {","        precondition(i < endIndex, \"Can't advance beyond endIndex\")","        return i + 1","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Because ","type":"text"},{"code":"CollectionOfTwo","type":"codeVoice"},{"type":"text","text":" doesn’t define its own "},{"type":"codeVoice","code":"makeIterator()"},{"type":"text","text":" "},{"text":"method or ","type":"text"},{"type":"codeVoice","code":"Iterator"},{"type":"text","text":" associated type, it uses the default iterator type,"},{"text":" ","type":"text"},{"code":"IndexingIterator","type":"codeVoice"},{"text":". This example shows how a ","type":"text"},{"type":"codeVoice","code":"CollectionOfTwo"},{"type":"text","text":" instance"},{"type":"text","text":" "},{"text":"can be created holding the values of a point, and then iterated over","type":"text"},{"type":"text","text":" "},{"type":"text","text":"using a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":" loop."}]},{"code":["let point = CollectionOfTwo(15.0, 20.0)","for element in point {","    print(element)","}","\/\/ Prints \"15.0\"","\/\/ Prints \"20.0\""],"type":"codeListing","syntax":null}]}],"kind":"symbol","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator"},"metadata":{"title":"IndexingIterator","externalID":"s:s16IndexingIteratorV","role":"symbol","modules":[{"name":"Compute"}],"roleHeading":"Structure","symbolKind":"struct","fragments":[{"kind":"keyword","text":"struct"},{"text":" ","kind":"text"},{"kind":"identifier","text":"IndexingIterator"}],"navigatorTitle":[{"text":"IndexingIterator","kind":"identifier"}]},"topicSections":[{"identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator\/SubSequence"],"title":"Type Aliases","generated":true,"anchor":"Type-Aliases"},{"title":"Default Implementations","anchor":"Default-Implementations","generated":true,"identifiers":["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator\/IteratorProtocol-Implementations","doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator\/Sequence-Implementations"]}],"schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"abstract":[{"type":"text","text":"A type that iterates over a collection using its indices."}],"variants":[{"paths":["\/documentation\/compute\/indexingiterator"],"traits":[{"interfaceLanguage":"swift"}]}],"hierarchy":{"paths":[["doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute"]]},"references":{"doc://com.swallow.documentation.Compute/documentation/Compute/Copyable":{"url":"\/documentation\/compute\/copyable","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Copyable","role":"symbol","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Copyable","kind":"identifier"}],"navigatorTitle":[{"kind":"identifier","text":"Copyable"}],"type":"topic","conformance":{"constraints":[{"type":"codeVoice","code":"Elements"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Collection"},{"text":".","type":"text"}],"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}]},"title":"Copyable","kind":"symbol","abstract":[{"type":"text","text":"A type whose values can be implicitly or explicitly copied."}]},"doc://com.swallow.documentation.Compute/documentation/Compute/IndexingIterator/Sequence-Implementations":{"title":"Sequence Implementations","type":"topic","abstract":[],"kind":"article","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator\/Sequence-Implementations","url":"\/documentation\/compute\/indexingiterator\/sequence-implementations","role":"collectionGroup"},"doc://com.swallow.documentation.Compute/documentation/Compute/IteratorProtocol":{"title":"IteratorProtocol","url":"\/documentation\/compute\/iteratorprotocol","type":"topic","role":"symbol","kind":"symbol","abstract":[{"type":"text","text":"A type that supplies the values of a sequence one at a time."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IteratorProtocol","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"IteratorProtocol"}],"navigatorTitle":[{"text":"IteratorProtocol","kind":"identifier"}],"conformance":{"constraints":[{"type":"codeVoice","code":"Elements"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Collection"},{"text":".","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"availabilityPrefix":[{"text":"Available when","type":"text"}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/Collection":{"kind":"symbol","role":"symbol","type":"topic","fragments":[{"text":"protocol","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"Collection"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Collection","url":"\/documentation\/compute\/collection","abstract":[{"type":"text","text":"A sequence whose elements can be traversed multiple times,"},{"text":" ","type":"text"},{"text":"nondestructively, and accessed by an indexed subscript.","type":"text"}],"navigatorTitle":[{"kind":"identifier","text":"Collection"}],"title":"Collection"},"doc://com.swallow.documentation.Compute/documentation/Compute/IndexingIterator/IteratorProtocol-Implementations":{"abstract":[],"url":"\/documentation\/compute\/indexingiterator\/iteratorprotocol-implementations","title":"IteratorProtocol Implementations","role":"collectionGroup","kind":"article","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator\/IteratorProtocol-Implementations","type":"topic"},"doc://com.swallow.documentation.Compute/documentation/Compute/IndexingIterator":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator","title":"IndexingIterator","abstract":[{"type":"text","text":"A type that iterates over a collection using its indices."}],"kind":"symbol","navigatorTitle":[{"text":"IndexingIterator","kind":"identifier"}],"url":"\/documentation\/compute\/indexingiterator","type":"topic","role":"symbol","fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"text":"IndexingIterator","kind":"identifier"}]},"doc://com.swallow.documentation.Compute/documentation/Compute":{"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute","url":"\/documentation\/compute","role":"collection","kind":"symbol","abstract":[],"type":"topic","title":"Compute"},"doc://com.swallow.documentation.Compute/documentation/Compute/IndexingIterator/SubSequence":{"url":"\/documentation\/compute\/indexingiterator\/subsequence","kind":"symbol","role":"symbol","navigatorTitle":[{"text":"SubSequence","kind":"identifier"}],"type":"topic","fragments":[{"kind":"keyword","text":"typealias"},{"text":" ","kind":"text"},{"kind":"identifier","text":"SubSequence"}],"conformance":{"constraints":[{"type":"codeVoice","code":"Elements"},{"text":" conforms to ","type":"text"},{"code":"Collection","type":"codeVoice"},{"type":"text","text":"."}],"availabilityPrefix":[{"type":"text","text":"Available when"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}]},"abstract":[],"title":"IndexingIterator.SubSequence","identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/IndexingIterator\/SubSequence"},"doc://com.swallow.documentation.Compute/documentation/Compute/Sendable":{"type":"topic","role":"symbol","navigatorTitle":[{"text":"Sendable","kind":"identifier"}],"url":"\/documentation\/compute\/sendable","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Sendable","kind":"identifier"}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Sendable","title":"Sendable","abstract":[],"kind":"symbol","conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"type":"text","text":"Conforms when"}],"constraints":[{"code":"Elements","type":"codeVoice"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Collection"},{"type":"text","text":", "},{"type":"codeVoice","code":"Elements"},{"text":" conforms to ","type":"text"},{"type":"codeVoice","code":"Sendable"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"Elements.Index"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Sendable"},{"type":"text","text":"."}]}},"doc://com.swallow.documentation.Compute/documentation/Compute/Sequence":{"title":"Sequence","url":"\/documentation\/compute\/sequence","type":"topic","role":"symbol","kind":"symbol","abstract":[{"type":"text","text":"A type that provides sequential, iterated access to its elements."}],"identifier":"doc:\/\/com.swallow.documentation.Compute\/documentation\/Compute\/Sequence","fragments":[{"text":"protocol","kind":"keyword"},{"kind":"text","text":" "},{"text":"Sequence","kind":"identifier"}],"navigatorTitle":[{"text":"Sequence","kind":"identifier"}],"conformance":{"availabilityPrefix":[{"text":"Available when","type":"text"}],"conformancePrefix":[{"text":"Conforms when","type":"text"}],"constraints":[{"type":"codeVoice","code":"Elements"},{"type":"text","text":" conforms to "},{"code":"Collection","type":"codeVoice"},{"type":"text","text":"."}]}}}}